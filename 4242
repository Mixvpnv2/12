--helper
if not LPH_OBFUSCATED then
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Luraph/macrosdk/main/luraphsdk.lua"))();
end

do --// Obfuscated check
    if not LPH_OBFUSCATED then
        LPH_JIT = function(...) return ... end
        LPH_JIT_MAX = function(...) return ... end
        LPH_NO_VIRTUALIZE = function(...) return ... end
        LPH_NO_UPVALUES= function(f) return(function(...) return f(...) end) end
        LPH_ENCSTR = function(...) return ... end
        LPH_ENCNUM = function(...) return ... end
        LPH_CRASH = function() return print(debug.traceback()) end

        LRM_IsUserPremium = false 
        LRM_LinkedDiscordID = "Developer"
        LRM_ScriptName = "dev"
        LRM_TotalExecutions = 0
        LRM_SecondsLeft = 999999
        LRM_UserNote = "hello";

        if not gethui then 
            gethui = function() return game.Players.LocalPlayer.PlayerGui end; 
            IsStudio = true 
        end
    end;
end;

print("Enabled")
local function handleClientAntiCheatBypass()
    if ACBYPASS_SYNC == true then return end

    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(self, ...)
        local Method = getnamecallmethod()
        local Args = {...}
        if Method == "FireServer" and self.Name == "ProjectileInflict" and true then
            if Args[1] == game.Players.LocalPlayer.Character.HumanoidRootPart then
                return coroutine.yield()
            end
        end
        return oldNamecall(self, ...)
    end)
    setreadonly(mt, true)

    ACBYPASS_SYNC = true
end
handleClientAntiCheatBypass()

repeat 
	task.wait();
until game:IsLoaded();



if setidentity then
	setidentity(3); 
end;

-- Variables
local Players = game:GetService("Players");
local LocalPlayer = Players.LocalPlayer;
local CurrentCamera = game:GetService("Workspace").CurrentCamera;
local RunService = game:GetService("RunService");
local UserInputService = game:GetService("UserInputService");
local MousePos = UserInputService:GetMouseLocation();
local AiZones = game:GetService("Workspace"):FindFirstChild("AiZones");
local FovHolder = Instance.new("ScreenGui", game.CoreGui);
local ClickTic = tick();

local viewmodbool = false
local viewmodhandmat = Enum.Material.Plastic
local viewmodgunmat = Enum.Material.Plastic
local viewmodhandcolor = Color3.fromRGB(255,255,255)
local viewmodguncolor = Color3.fromRGB(255,255,255)

local HitBoxes = {
	["Head"] = {"Head"},
	["Torso"] = {"Torso", "UpperTorso", "LowerTorso", "HumanoidRootPart"},
	["Arms"] = {"LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm"},
	["Legs"] = {"LeftFoot", "RightFoot", "LeftLowerLeg", "RightLowerLeg", "LeftUpperLeg", "RightUpperLeg"}
};

local settings = {
    aimbot = {
        enabled = true,
        hitchance = 100,
        targetai = true,
        prediction = true,
        vischeck = true,
        distance = 300,
    },

    modifiers = {
        doubletap = false,
        fullauto = false,
        recoil = 100,
        drop = 100,
        drag = 100,
        spread = 100,
    },

    zoom = {
        enabled = true,
        held = false,
        fov = 40,
    },

    ambient = {
        enabled = false,
        brightness = 0.3,
        saturation = 0,
        contrast = 0.3,
        color = Color3.fromRGB(255, 255, 255),
    },

    
    Juggernaut = false,
    DefaultFOV = defaultFov,
}

-- GUI
do
	local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/';

	local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))();
	local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))();
	local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))();

	Library:Notify("Hello Mixvpn own", 5)
	Library:Notify("Owner Version Ready", 5)

	local Window = Library:CreateWindow({
		Title = '| CatteState | Project Delta | V5 |',
		Center = true,
		AutoShow = true,
		TabPadding = 8,
		MenuFadeTime = 0.2
	});

	local Tabs = {
		['MainTab'] = Window:AddTab('Main'),
		['Legit'] = Window:AddTab('Combat'),
		['ESP'] = Window:AddTab('Visuals'),
		['Misc'] = Window:AddTab('Misc'),
		['UI Settings'] = Window:AddTab('Settings'),
        ['GunMods'] = Window:AddTab('GunMods'),
		['WorldMods'] = Window:AddTab('World'),
		['FovView'] = Window:AddTab('FOV'),
	};

	local LeftGroupBox = Tabs.Legit:AddLeftGroupbox('            AimBot');
	LeftGroupBox:AddDivider()
	LeftGroupBox:AddToggle('AimbotEnable', {Text = 'Enable', Default = false, Tooltip = 'Enables The Aimbot.', Callback = function() end});
	LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('AimbotToggle', {Default = 'MB2', SyncToggleState = false, Mode = 'Hold',Text = 'Keybind', NoUI = false, OnClick = function() ClickTic = tick(); end, ChangedCallback = function() end});
	LeftGroupBox:AddToggle('AimbotWallCheck', {Text = 'Wall Check', Default = false, Tooltip = 'Checks If There Is Something Obstructing The Vision To The Enemy.', Callback = function() end});
	LeftGroupBox:AddSlider('AimbotSmoothing', {Text = 'Speed', Default = 2500, Min = 1,Max = 2500, Rounding = 1,Compact = false, Callback = function() end});
	LeftGroupBox:AddDropdown('AimbotHitScan', {Values = { 'Head', 'Torso', 'Arms', 'Legs' }, Default = 1, Multi = true, Text = 'Hit Scan', Tooltip = 'What Parts Of The Body Will The Aimbot Target.', Callback = function() end});
	LeftGroupBox:AddDivider()
	LeftGroupBox:AddToggle('AimbotShowFov', {Text = 'Draw Fov', Default = false, Tooltip = 'Shows The Fov.', Callback = function() end}):AddColorPicker('AimbotFovColor', {Default = Color3.new(1, 1, 1), Title = 'Color Of The Fov', Transparency = nil, Callback = function() end});
	LeftGroupBox:AddSlider('AimbotFovSize', {Text = 'Fov', Default = 600, Min = 0,Max = 1000, Rounding = 1,Compact = false, Callback = function() end});
	LeftGroupBox:AddDivider()

	local RightGroupBox = Tabs.Legit:AddRightGroupbox('            Silent Aim');
	RightGroupBox:AddDivider()
	RightGroupBox:AddToggle('SilentAimEnable', {Text = 'Enable', Default = false, Tooltip = 'Enables The Silent Aim.', Callback = function() end});
    RightGroupBox:AddToggle('SilentAimShowCenterDot', {
    Text = 'Center Dot',
    Default = false,
    Tooltip = 'Enables the center dot inside FOV',
    Callback = function(state)
        Toggles.SilentAimShowCenterDot.Value = state
    end
})
	RightGroupBox:AddToggle('SilentAimWallCheck', {Text = 'Wall Check', Default = false, Tooltip = 'Checks If There Is Something Obstructing The Vision To The Enemy.', Callback = function() end});
	RightGroupBox:AddToggle('AimbotWallCheck', {
    Text = 'Target AI',
    Default = false,
    Tooltip = 'Targets AIS',
    Callback = function(v)
        aimbots = v
    end
})
	RightGroupBox:AddDropdown('SilentAimHitScan', {Values = { 'Head', 'Torso', 'Arms', 'Legs' }, Default = 1, Multi = true, Text = 'Hit Scan', Tooltip = 'What Parts Of The Body Will The Silent Aim Target.', Callback = function() end});
	RightGroupBox:AddSlider('SilentAimHitChance', {Text = 'Hit Chance', Default = 100, Min = 0,Max = 100, Rounding = 1,Compact = false, Callback = function() end});
    RightGroupBox:AddToggle('SilentAimShowFov', {
    Text = 'Draw Fov',
    Default = false,
    Tooltip = 'Shows The Fov.',
    Callback = function() end
})
:AddColorPicker('SilentAimFovOutlineColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Outline Color',
    Transparency = nil,
    Callback = function() end
})
:AddColorPicker('GradientColor1', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Gradient Start',
    Transparency = nil,
    Callback = function() end
})
:AddColorPicker('GradientColor2', {
    Default = Color3.fromRGB(0, 255, 255),
    Title = 'Gradient End',
    Transparency = nil,
    Callback = function() end
})

RightGroupBox:AddToggle('SilentAimFovGradientSpin', {
    Text = 'Rotate Gradient',
    Default = false,
    Tooltip = 'Rotates the color gradient around the FOV circle.',
    Callback = function() end
})
    RightGroupBox:AddSlider('SilentAimFovGradientSpeed', {
    Text = 'Gradient Spin Speed',
    Default = 50,
    Min = 5,
    Max = 200,
    Rounding = 0,
    Tooltip = 'Controls how fast the gradient spins around the circle.',
    Callback = function() end
})

RightGroupBox:AddToggle('SilentAimFovEffects', {
    Text = 'FOV Effects',
    Default = false,
    Tooltip = 'Enables gradient, spin, rainbow, and any other FOV visual effects.',
    Callback = function(Value)
        if Value then
            print("FOV effects enabled")
        else
            print("FOV effects disabled")
        end
    end
})

RightGroupBox:AddToggle('SilentAimFovRainbow', {
    Text = 'Rainbow Fov',
    Default = false,
    Tooltip = 'Makes the FOV circle spin with changing rainbow colors.',
    Callback = function() end
})
	RightGroupBox:AddSlider('SilentAimFovSize', {Text = 'Fov', Default = 600, Min = 0,Max = 2000, Rounding = 1,Compact = false, Callback = function() end});
	RightGroupBox:AddDivider()

	local ESPMain = Tabs.ESP:AddLeftGroupbox('Players');
	ESPMain:AddToggle('DrawESP', {Text = 'Enable', Default = false, Tooltip = 'Enables The ESP.', Callback = function() end});
	ESPMain:AddToggle('DrawGradients', {Text = 'Use Gradients', Default = false, Tooltip = '', Callback = function() end});
	ESPMain:AddToggle('ESPAnimation', {Text = 'Animate', Default = false, Tooltip = '', Callback = function() end});
	ESPMain:AddToggle('DrawBoxes', {Text = 'Box', Default = false, Tooltip = '', Callback = function() end}):AddColorPicker('Boxes1', {Default = Color3.new(1, 1, 1), Title = 'Color Box', Transparency = nil, Callback = function() end}):AddColorPicker('Boxes2', {Default = Color3.new(1, 1, 1), Title = 'Color Of The Box 2', Transparency = nil, Callback = function() end});
	ESPMain:AddToggle('DrawFill', {Text = 'Fill Box', Default = false, Tooltip = '', Callback = function() end}):AddColorPicker('Fill1', {Default = Color3.new(1, 1, 1), Title = 'Color Fill', Transparency = nil, Callback = function() end}):AddColorPicker('Fill2', {Default = Color3.new(1, 1, 1), Title = 'Color Of The Fill 2', Transparency = nil, Callback = function() end});
	ESPMain:AddSlider('DrawFillTransparency', {Text = 'Fill Transparency', Default = 75, Min = 0,Max = 100, Rounding = 1,Compact = false, Callback = function() end});
	ESPMain:AddToggle('DrawName', {Text = 'Name', Default = false, Tooltip = '', Callback = function() end}):AddColorPicker('Name1', {Default = Color3.new(1, 1, 1), Title = 'Color Of Name Text.', Transparency = nil, Callback = function() end});
	ESPMain:AddToggle('DrawDstance', {Text = 'Distance', Default = false, Tooltip = '', Callback = function() end}):AddColorPicker('Distance1', {Default = Color3.new(1, 1, 1), Title = 'Color Of Distance Text.', Transparency = nil, Callback = function() end});
	ESPMain:AddToggle('DrawGun', {Text = 'Gun', Default = false, Tooltip = '', Callback = function() end}):AddColorPicker('Gun1', {Default = Color3.new(1, 1, 1), Title = 'Color Of Gun Text.', Transparency = nil, Callback = function() end});

	local UISettingsLeft = Tabs['UI Settings']:AddLeftGroupbox('Menu')
	UISettingsLeft:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'RightShift', NoUI = true, Text = 'Menu keybind' });
	Library.ToggleKeybind = Options.MenuKeybind;
	UISettingsLeft:AddDivider()
	UISettingsLeft:AddButton('Dex Explorer PP', function() loadstring(game:HttpGet("https://raw.githubusercontent.com/Mixvpnv2/Dexpp/refs/heads/main/dexpp"))() end)
	UISettingsLeft:AddDivider() 
	ThemeManager:SetLibrary(Library);
	SaveManager:SetLibrary(Library);
	SaveManager:IgnoreThemeSettings();
	SaveManager:SetIgnoreIndexes({ 'MenuKeybind' });
	ThemeManager:SetFolder('JIGGYB02');
	SaveManager:SetFolder('JIGGYB02/JIGGY MENU');
	SaveManager:BuildConfigSection(Tabs['UI Settings']);
	ThemeManager:ApplyToTab(Tabs['UI Settings']);

	local UISettingsLeft = Tabs['UI Settings']:AddRightGroupbox('Menu')
	UISettingsLeft:AddDivider()
    local draw = { objects = {} }

function draw:new(typeName, props)
    local obj = Drawing.new(typeName)
    for k, v in pairs(props) do
        obj[k] = v
    end
    table.insert(self.objects, obj)
    return obj
end

function draw:changevis(state)
    for _, obj in pairs(self.objects) do
        obj.Visible = state
    end
end

UISettingsLeft:AddToggle('showwatermark', {
    Text = 'watermark',
    Default = true,
    Callback = function(v)
        if draw and draw.changevis then
            draw:changevis(v)
        end
    end
})
:AddColorPicker('watercolor', {
    Default = Color3.fromRGB(120, 110, 230),
    Title = 'watermark color',
    Transparency = 0
})

local RunService = game:GetService("RunService")

local function getTopLeft()
    return Vector2.new(190, 10)
end

local topleftpos = getTopLeft()

local backgroundYOffset = 10
local backgroundThickness = 23

local background = draw:new("Line", {
    From = topleftpos + Vector2.new(0, backgroundYOffset),
    To = topleftpos + Vector2.new(400, backgroundYOffset),
    Thickness = backgroundThickness,
    Transparency = 0.7,
    Visible = true,
    Color = Color3.new(0, 0, 0),
    ZIndex = 1,
})

local topbar = draw:new("Line", {
    From = topleftpos,
    To = topleftpos + Vector2.new(400, 0),
    Thickness = 1,
    Transparency = 1,
    Visible = true,
    Color = Options["watercolor"].Value,
    ZIndex = 2,
})

local topbar2 = draw:new("Line", {
    From = topleftpos + Vector2.new(0, 1),
    To = topleftpos + Vector2.new(400, 1),
    Thickness = 1,
    Transparency = 1,
    Visible = true,
    Color = Options["watercolor"].Value,
    ZIndex = 2,
})

local watermarkText = draw:new("Text", {
    Text = "CatteState v5 | Build: Owner | Made By: Mixvpn | 0 fps | 0 ms",
    Size = 15,
    Font = 1,
    Outline = true,
    Center = false,
    Position = topleftpos + Vector2.new(5, -5 + backgroundYOffset),
    Transparency = 1,
    Visible = true,
    Color = Options["watercolor"].Value,
    ZIndex = 3,
})

draw:changevis(true)

local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

RunService.Stepped:Connect(function()
    local topleftpos = getTopLeft()
    local width = watermarkText.TextBounds.X + 10

    topbar.From = topleftpos
    topbar.To = topleftpos + Vector2.new(width, 0)

    topbar2.From = topleftpos + Vector2.new(0, 1)
    topbar2.To = topleftpos + Vector2.new(width, 1)

    background.From = topleftpos + Vector2.new(0, backgroundYOffset)
    background.To = topleftpos + Vector2.new(width, backgroundYOffset)
    background.Thickness = backgroundThickness

    watermarkText.Position = topleftpos + Vector2.new(5, -5 + backgroundYOffset)

    local color = Options["watercolor"].Value
    topbar.Color = color
    topbar2.Color = color
    watermarkText.Color = color

    FrameCounter += 1
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())

    watermarkText.Text = string.format(
        "CatteState v5 | Build: Owner | Made By: Mixvpn | %d fps | %d ms",
        math.floor(FPS),
        ping
    )
end)
	UISettingsLeft:AddButton('Unload', function() Library:Unload() end)
	UISettingsLeft:AddButton('Rejoin', function() game:GetService('TeleportService'):TeleportToPlaceInstance(game.PlaceId, game.JobId) end)
    UISettingsLeft:AddToggle('keybindlist', {
        Text = 'Keybinds',
        Default = Library.KeybindFrame.Visible,
    
        Callback = function(Value)
            Library.KeybindFrame.Visible = Value
        end
    })
	UISettingsLeft:AddDivider()

	local MainTab = Tabs.MainTab:AddLeftGroupbox('             Credits')
	MainTab:AddDivider()
	MainTab:AddLabel('Owner: Mixvpn')
	MainTab:AddBlank(5)
	MainTab:AddLabel('Main Dev: danger_lonya')
	MainTab:AddBlank(5)
	MainTab:AddLabel('UI Dev: Hidden')
	MainTab:AddDivider()
	MainTab:AddLabel('Staff Mixvpn')
	MainTab:AddDivider()

	local Legit = Tabs.Legit:AddRightGroupbox('Auto Shoot')
	local keybindCreated = false  

	Legit:AddToggle('Enabled', {
    Text = 'Enabled',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        if v then
            if not keybindCreated then  
                Legit:AddLabel('Keybind')
                    :AddKeyPicker('AimbotToggle', {
                        Default = 'MB2',
                        SyncToggleState = false,
                        Mode = 'Hold',
                        Text = 'Keybind',
                        NoUI = false,
                        OnClick = function()
                            ClickTic = tick()  
                        end,
                        ChangedCallback = function() end
                    })
                keybindCreated = true  
            end
            aimtrigger = true  
        else
            aimtrigger = false  
        end
    end
})
	
	Legit:AddDropdown('Auto Shoot Mode', {
		Values = { "Standard", "Adaptive" },
		Default = 1,
		Multi = false,
		Text = 'Autoshoot Mode',
		Callback = function(Value)
			value = Value
		end
	})	
	

	local Legit = Tabs.Legit:AddRightGroupbox('Target Info')
	Legit:AddDivider()
    local InvViewMain
    local invColor = Color3.new(1, 1, 1) 

    Legit:AddToggle('Inventory Viewer', {
    Text = 'Inventory Viewer',
    Default = false,
    Tooltip = 'Enables The Inventory Viewer',
    Callback = function(state)
        if state then
            if not InvViewMain then
                local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
                local screenGui = playerGui:FindFirstChild("ScreenGui") or Instance.new("ScreenGui", playerGui)
                screenGui.Name = "ScreenGui"

                InvViewMain = Instance.new("Frame")
                local InvView1 = Instance.new("Frame")
                local InventoryLabel = Instance.new("TextLabel")

                InvViewMain.Name = "InvViewMain"
                InvViewMain.Parent = screenGui

                InvViewMain.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                InvViewMain.BackgroundTransparency = 0.3
                InvViewMain.BorderSizePixel = 0
                InvViewMain.Position = UDim2.new(0.0048, 0, 0.2189, 0)
                InvViewMain.Size = UDim2.new(0, 170, 0, 400)
                InvViewMain.Visible = true

                InvView1.Name = "InvView1"
                InvView1.Parent = InvViewMain
                InvView1.Size = UDim2.new(0, 166, 0, 396)  
                InvView1.AnchorPoint = Vector2.new(0.5, 0.5)
                InvView1.Position = UDim2.new(0.5, 0, 0.5, 0)
                
                InvView1.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                InvView1.BackgroundTransparency = 0.3
                InvView1.BorderSizePixel = 0

                InventoryLabel.Name = "InventoryLabel"
                InventoryLabel.Parent = InvView1
                InventoryLabel.BackgroundTransparency = 1
                InventoryLabel.TextColor3 = invColor
                InventoryLabel.TextStrokeTransparency = 0
                InventoryLabel.TextXAlignment = Enum.TextXAlignment.Left
                InventoryLabel.TextYAlignment = Enum.TextYAlignment.Top
                InventoryLabel.Font = Enum.Font.SourceSans
                InventoryLabel.TextSize = 15
                InventoryLabel.TextWrapped = true
                InventoryLabel.Text = ""
                InventoryLabel.Position = UDim2.new(0, 15, 0, 0)
                InventoryLabel.Size = UDim2.new(1, -15, 0, 0)

                local dragging, dragInput, dragStart, startPos
                local userInputService = game:GetService("UserInputService")
                InvViewMain.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        dragging = true
                        dragStart = input.Position
                        startPos = InvViewMain.Position
                        input.Changed:Connect(function()
                            if input.UserInputState == Enum.UserInputState.End then
                                dragging = false
                            end
                        end)
                    end
                end)
                InvViewMain.InputChanged:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseMovement then
                        dragInput = input
                    end
                end)
                userInputService.InputChanged:Connect(function(input)
                    if input == dragInput and dragging then
                        local delta = input.Position - dragStart
                        InvViewMain.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
                    end
                end)

                local ignore = {
                    "ItemProperties", "Tear", "ItemIcon", "Resource1", "Clothing",
                    "BodyParts", "Protection", "Template", "Attachments", "SettingsModule",
                }
                local function locate(tab, val)
                    for _, v in ipairs(tab) do
                        if v == val then return true end
                    end
                    return false
                end
                local function getInventory(p)
                    local rsP = game.ReplicatedStorage:FindFirstChild("Players")
                    local plrData = rsP and rsP:FindFirstChild(p.Name)
                    if not plrData then return "No inventory found" end

                    local journey = plrData:FindFirstChild("Status") and plrData.Status:FindFirstChild("Journey")
                    local wipeStats = journey and journey:FindFirstChild("WipeStatistics")
                    local lootWorth = wipeStats and wipeStats:GetAttribute("LootWorth") or "N/A"
                    local out = "- Value: " .. tostring(lootWorth) .. "\n- Hotbar:\n"

                    local inv = plrData:FindFirstChild("Inventory")
                    if inv then
                        for _, item in ipairs(inv:GetChildren()) do
                            if item and not locate(ignore, item.Name) then
                                out = out .. item.Name .. "\n"
                            end
                        end
                    end

                    out = out .. "- Equipment:\n"
                    if inv then
                        for _, item in ipairs(inv:GetChildren()) do
                            local slot = item:GetAttribute("Slot")
                            if slot and slot:find("Clothing") then
                                out = out .. "    " .. item.Name .. "\n"
                                local itemInv = item:FindFirstChild("Inventory")
                                if itemInv then
                                    for _, subitem in ipairs(itemInv:GetChildren()) do
                                        local amount = subitem:FindFirstChild("ItemProperties") and subitem.ItemProperties:GetAttribute("Amount")
                                        out = out .. "        " .. subitem.Name .. (amount and " x" .. amount or "") .. "\n"
                                    end
                                end
                            end
                        end
                    end

                    return out
                end

                local camera = game.Workspace.CurrentCamera
                local players = game:GetService("Players")
                local localPlayer = players.LocalPlayer
                local RunService = game:GetService("RunService")

                task.spawn(function()
                    local oldText = ""
                    while InvViewMain and InvViewMain.Parent and wait(0.25) do
                        local best, fov, dist = nil, Options.SilentAimFovSize.Value / 2, math.huge
                        local center = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

                        for _, p in ipairs(players:GetPlayers()) do
                            if p ~= localPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                                local hum = p.Character:FindFirstChild("Humanoid")
                                local head = p.Character:FindFirstChild("Head")
                                if hum and hum.Health > 0 and head then
                                    local screen, onScreen = camera:WorldToViewportPoint(head.Position)
                                    local mag = (center - Vector2.new(screen.X, screen.Y)).Magnitude
                                    if onScreen and mag < fov and mag < dist then
                                        best, dist = p, mag
                                    end
                                end
                            end
                        end

                        if best then
                            local invText = getInventory(best)
                            if invText ~= oldText then
                                InventoryLabel.Text = invText
                                local lines = #string.split(invText, "\n")
                                local contentHeight = lines * InventoryLabel.TextSize + 10

                                InventoryLabel.Size = UDim2.new(1, -15, 0, contentHeight)
                                InvView1.Size = UDim2.new(0, 166, 0, contentHeight + 5)
                                InvViewMain.Size = UDim2.new(0, 170, 0, contentHeight + 10)
                                oldText = invText
                            end

                            InventoryLabel.TextColor3 = invColor
                            InvViewMain.Visible = true
                        else
                            InvViewMain.Visible = false
                        end
                    end
                end)
            else
                InvViewMain.Visible = true
            end
        else
            if InvViewMain then
                InvViewMain.Visible = false
            end
        end
    end
}):AddColorPicker('Inventory Color', {
    Default = Color3.new(1, 1, 1),
    Title = 'Color Of Text.',
    Callback = function(color)
        invColor = color
        if InvViewMain and InvViewMain:FindFirstChild("InvView1") and InvViewMain.InvView1:FindFirstChild("InventoryLabel") then
            InvViewMain.InvView1.InventoryLabel.TextColor3 = invColor
        end
    end
})
	Legit:AddDivider()

    local Legit = Tabs.Legit:AddRightGroupbox('Join And Leave Logs')
	Legit:AddDivider()
    Legit:AddToggle('Join', {
    Text = 'join',
    Default = false,
    Tooltip = 'Notify on player join',
    Callback = function(v)
        joindetect = v
    end
})
    Legit:AddToggle('Leave', {
    Text = 'leave',
    Default = false,
    Tooltip = 'Notify on player leave',
    Callback = function(v)
        leavedetect = v
    end
})

game.Players.PlayerAdded:Connect(function(plr)
    if joindetect then
        Library:Notify(plr.Name .. " joined this server", 3, Color3.fromRGB(0,255,0))
    end
end)
game.Players.PlayerRemoving:Connect(function(plr)
    if leavedetect then
        Library:Notify(plr.Name .. " left this server", 3, Color3.fromRGB(255,0,0))
    end
end)
    Legit:AddDivider()

	local Legit = Tabs.Legit:AddLeftGroupbox('Target Snapline')
	Legit:AddDivider()
	getgenv().SnaplineColor = Color3.fromRGB(0, 255, 0)
    getgenv().Snapline = nil
    getgenv().SnaplineThread = nil
    getgenv().SnaplineRunning = false
    getgenv().SnaplinePosition = "Bottom"

    Legit:AddToggle('Target Snapline', {
    Text = 'Target Snapline',
    Default = false,
    Tooltip = 'Enable or disable the target snapline.',
    Callback = function(state)
        getgenv().Players = game:GetService("Players")
        getgenv().CurrentCamera = workspace.CurrentCamera
        getgenv().LocalPlayer = Players.LocalPlayer
        getgenv().Mouse = LocalPlayer:GetMouse()

        getgenv().AimbotSettings = {
            FovSize = Options.SilentAimFovSize.Value / 2
        }

        if state then
            if not Snapline then
                Snapline = Drawing.new("Line")
                Snapline.Color = SnaplineColor
                Snapline.Thickness = 2
                Snapline.Transparency = 0.5
                Snapline.Visible = false
            end

            SnaplineRunning = true
            SnaplineThread = task.spawn(function()
                while SnaplineRunning do
                    local MouseVector = Vector2.new(Mouse.X, Mouse.Y)
                    local SnaplineClosestPlayer = nil
                    local ClosestDistance = math.huge

                    for _, Player in ipairs(Players:GetPlayers()) do
                        if Player == LocalPlayer or not Player.Character then continue end

                        local Humanoid = Player.Character:FindFirstChildOfClass("Humanoid")
                        local HRP = Player.Character:FindFirstChild("HumanoidRootPart")
                        if not Humanoid or not HRP or Humanoid.Health <= 0 then continue end

                        local Pos, OnScreen = CurrentCamera:WorldToViewportPoint(HRP.Position)
                        if not OnScreen then continue end

                        local Dist = (Vector2.new(Pos.X, Pos.Y) - MouseVector).Magnitude
                        if Dist < AimbotSettings.FovSize and Dist < ClosestDistance then
                            SnaplineClosestPlayer = Player
                            ClosestDistance = Dist

                            local fromPos
                            if SnaplinePosition == "Top" then
                                fromPos = Vector2.new(CurrentCamera.ViewportSize.X / 2, 0)
                            elseif SnaplinePosition == "Middle" then
                                fromPos = Vector2.new(CurrentCamera.ViewportSize.X / 2, CurrentCamera.ViewportSize.Y / 2)
                            else
                                fromPos = Vector2.new(CurrentCamera.ViewportSize.X / 2, CurrentCamera.ViewportSize.Y)
                            end

                            Snapline.From = fromPos
                            Snapline.To = Vector2.new(Pos.X, Pos.Y)
                            Snapline.Visible = true
                        end
                    end

                    if not SnaplineClosestPlayer and Snapline then
                        Snapline.Visible = false
                    end

                    task.wait(0.05) 
                end
            end)
        else
            SnaplineRunning = false
            if Snapline then
                Snapline.Visible = false
            end
        end
    end
}):AddColorPicker('Snapline Color', {
    Default = SnaplineColor,
    Tooltip = 'Choose the color for the snapline.',
    Callback = function(color)
        SnaplineColor = color
        if Snapline then
            Snapline.Color = SnaplineColor
        end
    end
})

Legit:AddDropdown('Snapline Start', {
    Values = { 'Bottom', 'Middle', 'Top' },
    Default = 'Bottom',
    Tooltip = 'Choose where the snapline starts from.',
    Callback = function(option)
        SnaplinePosition = option
    end
})
	Legit:AddDivider()

	local Legit = Tabs.Legit:AddLeftGroupbox('Mod Status')
	Legit:AddDivider()
    getgenv().DetectModsEnabled = false
    getgenv().ModDetectionFired = false
    getgenv().DetectedMods = {}

    Legit:AddToggle('Mod Detector', {
    Text = 'Mod Detector',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        if scriptloading then return end

        getgenv().DetectModsEnabled = state
        if not state then
            getgenv().ModDetectionFired = false
            table.clear(getgenv().DetectedMods)
        end
    end
})

getgenv().HandleModDetection = function(plrname, reason)
    getgenv().DetectedMods[plrname] = true
    if getgenv().ModDetectionFired then return end
    getgenv().ModDetectionFired = true

    print("Mod Detected: " .. reason .. " (" .. plrname .. ")")
    Library:Notify(plrname .. " joined with suspicious activity: " .. reason, 5)
end

task.spawn(function()
    while task.wait(1) do
        if getgenv().DetectModsEnabled then
            for _, player in ipairs(game.Players:GetPlayers()) do
                if getgenv().DetectedMods[player.Name] then continue end

                local pinfo = game.ReplicatedStorage.Players:FindFirstChild(player.Name)
                if not pinfo then continue end

                local status = pinfo:FindFirstChild("Status")
                if not status then continue end

                local uac = status:FindFirstChild("UAC")
                local vars = status:FindFirstChild("GameplayVariables")
                if not uac or not vars then continue end

                if uac:GetAttribute("Enabled") == true then
                    getgenv().HandleModDetection(player.Name, "UAC Enabled")
                elseif vars:GetAttribute("Godmode") == true then
                    getgenv().HandleModDetection(player.Name, "Godmode Enabled")
                elseif vars:GetAttribute("PremiumLevel") and vars:GetAttribute("PremiumLevel") >= 4 then
                    getgenv().HandleModDetection(player.Name, "PremiumLevel >= 4")
                elseif uac:GetAttribute("A1Detected") == true then
                    getgenv().HandleModDetection(player.Name, "A1 Detected")
                elseif uac:GetAttribute("A2Detected") == true then
                    getgenv().HandleModDetection(player.Name, "A2 Detected")
                elseif uac:GetAttribute("A3Detected") == true then
                    getgenv().HandleModDetection(player.Name, "A3 Detected")
                end
            end
        end
    end
end)

print("Mod Detection System Loaded")
	Legit:AddDivider()

	local Legit = Tabs.Legit:AddLeftGroupbox('Target Visible')
	Legit:AddDivider()
	_G.TargetHudSettings = _G.TargetHudSettings or {
        enabled = false,
        x = workspace.CurrentCamera.ViewportSize.X / 2,
        y = workspace.CurrentCamera.ViewportSize.Y / 2,
        color = Color3.fromRGB(255, 255, 255)
    }
    
    _G.HudHue = 0
    _G.TargetHudName = Drawing.new("Text")
    _G.TargetHudVis = Drawing.new("Text")
    
    _G.TargetHudName.Outline = true
    _G.TargetHudName.Center = true
    
    _G.TargetHudVis.Outline = true
    _G.TargetHudVis.Center = true
    
    local function RainbowColor()
        _G.HudHue = (_G.HudHue + 1) % 360
        return Color3.fromHSV(_G.HudHue / 360, 1, 1)
    end
    
    Legit:AddToggle('targethud', {
        Text = "Show Target Visible",
        Default = _G.TargetHudSettings.enabled,
        Callback = function(Value)
            _G.TargetHudSettings.enabled = Value
        end
    })
    
    Legit:AddSlider('targethudy', {
        Text = 'TargetHud Y Position',
        Default = _G.TargetHudSettings.y,
        Min = 0,
        Max = workspace.CurrentCamera.ViewportSize.Y,
        Rounding = 1,
        Compact = true,
        Callback = function(Value)
            _G.TargetHudSettings.y = Value
        end
    })
    
    Legit:AddSlider('targethudx', {
        Text = 'TargetHud X Position',
        Default = _G.TargetHudSettings.x,
        Min = 0,
        Max = workspace.CurrentCamera.ViewportSize.X,
        Rounding = 1,
        Compact = true,
        Callback = function(Value)
            _G.TargetHudSettings.x = Value
        end
    })
    
    _G.Players = game:GetService("Players")
    _G.LocalPlayer = _G.Players.LocalPlayer
    _G.CurrentCamera = workspace.CurrentCamera
    
    function _G.GetBestTarget()
        local fov_radius = Options.SilentAimFovSize.Value / 2
        local mouse_position = Vector2.new(_G.CurrentCamera.ViewportSize.X / 2, _G.CurrentCamera.ViewportSize.Y / 2)
        local closest_target = nil
        local min_distance = math.huge
    
        for _, player in ipairs(_G.Players:GetPlayers()) do
            if player ~= _G.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local head = player.Character:FindFirstChild("Head")
                    if head then
                        local screen_pos, on_screen = _G.CurrentCamera:WorldToViewportPoint(head.Position)
                        if on_screen then
                            local dist = (mouse_position - Vector2.new(screen_pos.X, screen_pos.Y)).Magnitude
                            if dist <= fov_radius and dist < min_distance then
                                closest_target = player
                                min_distance = dist
                            end
                        end
                    end
                end
            end
        end
    
        return closest_target
    end
    
    function _G.IsTargetVisible(target)
        local root = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
        if not root then return false end
    
        local rayStart = _G.CurrentCamera.CFrame.Position
        local rayDirection = (root.Position - rayStart).Unit * 500
    
        local raycastParams = RaycastParams.new()
        raycastParams.IgnoreWater = true
        raycastParams.FilterDescendantsInstances = {_G.LocalPlayer.Character}
    
        local result = workspace:Raycast(rayStart, rayDirection, raycastParams)
    
        if result and result.Instance:IsDescendantOf(target.Character) then
            return true
        end
        return false
    end
    
    task.spawn(function()
        while true do
            local target = _G.GetBestTarget()
    
            if target and _G.TargetHudSettings.enabled then
                local rainbow = RainbowColor()
                _G.TargetHudName.Color = rainbow
                _G.TargetHudName.Text = target.Name
                _G.TargetHudName.Position = Vector2.new(_G.TargetHudSettings.x, _G.TargetHudSettings.y)
                _G.TargetHudName.Visible = true
    
                local visibilityStatus = _G.IsTargetVisible(target) and "Visible" or "Not Visible"
                _G.TargetHudVis.Color = rainbow
                _G.TargetHudVis.Position = Vector2.new(_G.TargetHudSettings.x, _G.TargetHudSettings.y + 16)
                _G.TargetHudVis.Text = visibilityStatus
                _G.TargetHudVis.Visible = true
            else
                _G.TargetHudName.Visible = false
                _G.TargetHudVis.Visible = false
            end
    
            task.wait(0.05) 
        end
    end)     
	Legit:AddDivider()

	local ESP = Tabs.ESP:AddLeftGroupbox('Other Visuals')
	ESP:AddDivider()
    drawsettings = {
        Cham = {
            enabled = false,
            rendertype = "AlwaysOnTop",  
            transparency = 0.5,
            color = Color3.fromRGB(255, 255, 255),
            Outline = {
                enabled = true,
                transparency = 0,
                color = Color3.fromRGB(255, 255, 255),
            }  
        }
    }
    
        ESP:AddToggle('cham', {
        Text = "Player Chams",
        Default = drawsettings.Cham.enabled,
        Callback = function(Value)
            drawsettings.Cham.enabled = Value
        end
    }):AddColorPicker('chamcolor', {
        Default = drawsettings.Cham.color,
        Title = 'Chams Color',
        Callback = function(Value)
            drawsettings.Cham.color = Value
        end
    })
    
        ESP:AddSlider('chamtransparency', {
        Text = 'Chams Transparency',
        Default = drawsettings.Cham.transparency,
        Min = 0,
        Max = 1,
        Rounding = 1,
        Compact = true,
        Callback = function(Value)
            drawsettings.Cham.transparency = Value
        end
    })
    
        ESP:AddToggle('chamoutline', {
        Text = "Cham Outline",
        Default = drawsettings.Cham.Outline.enabled,
        Callback = function(Value)
            drawsettings.Cham.Outline.enabled = Value
        end
    }):AddColorPicker('chamoutlinecolor', {
        Default = drawsettings.Cham.Outline.color,
        Title = 'Chams Outline Color',
        Callback = function(Value)
            drawsettings.Cham.Outline.color = Value
        end
    })
    
        ESP:AddSlider('chamoutlinetransparency', {
        Text = 'Chams Outline Transparency',
        Default = drawsettings.Cham.Outline.transparency,
        Min = 0,
        Max = 1,
        Rounding = 1,
        Compact = true,
        Callback = function(Value)
            drawsettings.Cham.Outline.transparency = Value
        end
    })
    
        ESP:AddDropdown('ChamType', {
        Values = { 'AlwaysOnTop', 'Occluded' },
        Default = 1,
        Multi = false,
        Compact = true,
        Text = 'Cham Type',
        Callback = function(Value)
            drawsettings.Cham.rendertype = Value
        end
    })
    
    Players = game:GetService("Players")
    LocalPlayer = Players.LocalPlayer
    
    function doesExist(char)
        return char and char:FindFirstChild("HumanoidRootPart")
    end
    
    function wtvp(position)
        local cam = workspace.CurrentCamera
        local screenPos, visible = cam:WorldToViewportPoint(position)
        return screenPos, visible, screenPos.Z
    end
    
    chamsCache = {}
    
    function createCham(char)
        if not chamsCache[char] then
            local cham = Instance.new("Highlight")
            cham.Name = "ChamHighlight"
            cham.Parent = game.CoreGui
            chamsCache[char] = cham
        end
        return chamsCache[char]
    end
    
    function updateChams(char, cham)
        if doesExist(char) then
            local position, visible, depth = wtvp(char.HumanoidRootPart.Position)
            cham.Enabled = visible and drawsettings.Cham.enabled
    
            if cham.Enabled then
                cham.Adornee = char
                cham.FillTransparency = drawsettings.Cham.transparency
                cham.FillColor = drawsettings.Cham.color
                
                if drawsettings.Cham.Outline.enabled then
                    cham.OutlineColor = drawsettings.Cham.Outline.color
                    cham.OutlineTransparency = drawsettings.Cham.Outline.transparency
                else
                    cham.OutlineColor = drawsettings.Cham.color
                    cham.OutlineTransparency = 1
                end
    
                cham.DepthMode = Enum.HighlightDepthMode[drawsettings.Cham.rendertype]
            end
        else
            cham.Enabled = false
        end
    end
    
    game:GetService("RunService").RenderStepped:Connect(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local char = player.Character
                local cham = createCham(char)
                updateChams(char, cham)
            end
        end
    end)        
	ESP:AddDivider()

	local ESP = Tabs.ESP:AddLeftGroupbox('Ambient Settings')
	ESP:AddDivider()
	_G.Lighting = game:GetService("Lighting")
    _G.Fullbright = _G.Lighting:FindFirstChild("Fullbright") or Instance.new("ColorCorrectionEffect", _G.Lighting)
    _G.Fullbright.Name = "Fullbright"
    _G.Fullbright.Enabled = false

_G.LightingValues = {
    brightness = _G.Lighting.Brightness,
    contrast = 1,
    saturation = 1,
    color = Color3.new(1, 1, 1)
}

_G.SettingsAmbient = settings.ambient

_G.UpdateFullbright = function()
    if _G.Fullbright then
        _G.Fullbright.Enabled = _G.SettingsAmbient.enabled
        _G.Fullbright.TintColor = _G.SettingsAmbient.enabled and _G.SettingsAmbient.color or _G.LightingValues.color
        _G.Fullbright.Saturation = _G.SettingsAmbient.enabled and _G.SettingsAmbient.saturation or _G.LightingValues.saturation
        _G.Fullbright.Brightness = _G.SettingsAmbient.enabled and _G.SettingsAmbient.brightness or _G.LightingValues.brightness
        _G.Fullbright.Contrast = _G.SettingsAmbient.enabled and _G.SettingsAmbient.contrast or _G.LightingValues.contrast
    end
end

    ESP:AddToggle('Ambient', {
    Text = "Ambient",
    Default = _G.SettingsAmbient.enabled,
    Callback = function(Value)
        _G.SettingsAmbient.enabled = Value
        _G.UpdateFullbright()
    end
}):AddColorPicker('ambientcolor', {
    Default = _G.SettingsAmbient.color,
    Title = 'Ambient',
    Callback = function(Value)
        _G.SettingsAmbient.color = Value
        _G.UpdateFullbright()
    end
})

    ESP:AddSlider('ambientsaturation', {
    Text = 'Ambient Saturation',
    Default = _G.SettingsAmbient.saturation,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.SettingsAmbient.saturation = Value
        _G.UpdateFullbright()
    end
})

    ESP:AddSlider('ambientbrightness', {
    Text = 'Ambient Brightness',
    Default = _G.SettingsAmbient.brightness,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.SettingsAmbient.brightness = Value
        _G.UpdateFullbright()
    end
})

    ESP:AddSlider('ambientcontrast', {
    Text = 'Ambient Contrast',
    Default = _G.SettingsAmbient.contrast,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        _G.SettingsAmbient.contrast = Value
        _G.UpdateFullbright()
    end
})

    _G.Lighting = game:GetService("Lighting")
    _G.OutdoorAmbientEnabled = false
    _G.WorldOutdoorColor = Color3.fromRGB(255, 255, 255)

    ESP:AddToggle('OutdoorAmbientToggle', {
    Text = 'Outdoor Ambient',
    Default = _G.OutdoorAmbientEnabled,
    Tooltip = 'Toggle Outdoor Ambient',
    Callback = function(state)
        _G.OutdoorAmbientEnabled = state

        _G.Lighting.OutdoorAmbient = _G.OutdoorAmbientEnabled and _G.WorldOutdoorColor or Color3.fromRGB(127, 127, 127)
    end
}):AddColorPicker('OutdoorAmbientColor', {
    Default = _G.WorldOutdoorColor,
    Title = 'Outdoor Ambient Color',
    Callback = function(newColor)
        if newColor then
            _G.WorldOutdoorColor = newColor
            if _G.OutdoorAmbientEnabled then
                _G.Lighting.OutdoorAmbient = _G.WorldOutdoorColor
            end
        end
    end
})

_G.Lighting.Changed:Connect(function(property)
    if _G.OutdoorAmbientEnabled and property == "OutdoorAmbient" then
        _G.Lighting.OutdoorAmbient = _G.WorldOutdoorColor
    end
end)

	ESP:AddDivider()

	local ESP = Tabs.ESP:AddRightGroupbox('            Visuals')
	ESP:AddDivider() 
    _G.BulletTracersEnabled = false
    _G.TracerColor = Color3.new(1, 1, 1)
    _G.TracerFadeRate = 1
    _G.TracerSize = 0.01
    _G.TracerTexture = "rbxassetid://446111271"

    local tracerTextures = {
    ["Glow"] = "http://www.roblox.com/asset/?id=78260707920108",
    ["Lighting"] = "http://www.roblox.com/asset/?id=131326755401058",
    ["Neon Pulse"] = "rbxassetid://10222100358",
    ["Laser Beam"] = "rbxassetid://7182631636",
    ["Electric Zap"] = "rbxassetid://13818657656",
    ["Glowing Line"] = "rbxassetid://13808853481",
    ["Sci-Fi Beam"] = "rbxassetid://9373002288"
}

    ESP:AddToggle('Bullet Tracers', {
    Text = 'Bullet Tracers',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        _G.BulletTracersEnabled = state
    end
}):AddColorPicker('Tracers Color', {
    Default = _G.TracerColor,
    Title = 'Color Of The Tracers',
    Callback = function(color)
        _G.TracerColor = color
    end
})

    ESP:AddSlider('Tracer Lifetime', {
    Text = 'Tracer Lifetime',
    Default = _G.TracerFadeRate,
    Min = 0.1,
    Max = 5,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        _G.TracerFadeRate = value
    end
})

    ESP:AddSlider('Tracer Size', {
    Text = 'Tracer Size',
    Default = _G.TracerSize,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        _G.TracerSize = value
    end
})

    ESP:AddDropdown('Tracer Texture', {
    Text = 'Tracer Texture',
    Values = { "Glow", "Lighting", "Neon Pulse", "Laser Beam", "Electric Zap", "Glowing Line", "Sci-Fi Beam" },
    Default = "Glow",
    Multi = false,
    Callback = function(selected)
        _G.TracerTexture = tracerTextures[selected] or "rbxassetid://10222100358"
    end
})

if not workspace:FindFirstChild("NoCollision") then
    local folder = Instance.new("Folder", workspace)
    folder.Name = "NoCollision"
end

_G.createBeam = function(Origin, Position, Color, Lifetime, Size)
    local part1 = Instance.new("Part", workspace.NoCollision)
    local part2 = Instance.new("Part", workspace.NoCollision)
    part1.Position = Origin
    part2.Position = Position
    part1.Anchored = true
    part2.Anchored = true
    part1.Transparency = 1
    part2.Transparency = 1
    part1.Size = Vector3.zero
    part2.Size = Vector3.zero
    part1.CanCollide = false
    part2.CanCollide = false

    local att1 = Instance.new("Attachment", part1)
    local att2 = Instance.new("Attachment", part2)

    local beam = Instance.new("Beam", workspace.NoCollision)
    beam.Attachment0 = att1
    beam.Attachment1 = att2
    beam.Color = ColorSequence.new(Color)
    beam.LightEmission = 1
    beam.LightInfluence = 1
    beam.TextureMode = Enum.TextureMode.Static
    beam.Texture = _G.TracerTexture or "http://www.roblox.com/asset/?id=446111271" 
    beam.Transparency = NumberSequence.new(0)
    beam.FaceCamera = true
    beam.Segments = 1
    beam.Width0 = Size
    beam.Width1 = Size

    task.delay(Lifetime, function()
        if part1 then part1:Destroy() end
        if part2 then part2:Destroy() end
        if beam then beam:Destroy() end
    end)
end

    local skeletonESPColor = Color3.fromRGB(255, 0, 0)
    local ESP_Enabled = false
    local PlayerESP = {}
    local DrawLine
    local ClearESP
    local DrawESP
    local UpdateLine
    local GetPartPos

    ESP:AddToggle('Skeleton ESP', {
    Text = 'Skeleton ESP',
    Default = false,
    Tooltip = 'Draws skeletons on players.',
    Callback = function(state)
        ESP_Enabled = state
        if ESP_Enabled then
            _G.Player = game:GetService("Players").LocalPlayer
            _G.Camera = workspace.CurrentCamera
            _G.RunService = game:GetService("RunService")
            _G.Players = game:GetService("Players")

            DrawLine = function()
                local line = Drawing.new("Line")
                line.Visible = false
                line.Color = skeletonESPColor
                line.Thickness = 1
                line.Transparency = 1
                return line
            end

            ClearESP = function(plr)
                if PlayerESP[plr] then
                    for _, line in pairs(PlayerESP[plr].limbs) do
                        line:Remove()
                    end
                    PlayerESP[plr].connection:Disconnect()
                    PlayerESP[plr] = nil
                end
            end

            DrawESP = function(plr)
                if PlayerESP[plr] then ClearESP(plr) end

                local R15 = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R15
                local limbs = {}

                if R15 then
                    limbs = {
                        Head_UpperTorso = DrawLine(),
                        UpperTorso_LowerTorso = DrawLine(),
                        UpperTorso_LeftUpperArm = DrawLine(),
                        LeftUpperArm_LeftLowerArm = DrawLine(),
                        LeftLowerArm_LeftHand = DrawLine(),
                        UpperTorso_RightUpperArm = DrawLine(),
                        RightUpperArm_RightLowerArm = DrawLine(),
                        RightLowerArm_RightHand = DrawLine(),
                        LowerTorso_LeftUpperLeg = DrawLine(),
                        LeftUpperLeg_LeftLowerLeg = DrawLine(),
                        LeftLowerLeg_LeftFoot = DrawLine(),
                        LowerTorso_RightUpperLeg = DrawLine(),
                        RightUpperLeg_RightLowerLeg = DrawLine(),
                        RightLowerLeg_RightFoot = DrawLine(),
                    }
                end

                local connection
                connection = _G.RunService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
                    if not ESP_Enabled then
                        for _, line in pairs(limbs) do
                            line.Visible = false
                        end
                        return
                    end

                    local char = plr.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    local hum = char and char:FindFirstChild("Humanoid")

                    if char and hrp and hum and hum.Health > 0 then
                        local _, onScreen = _G.Camera:WorldToViewportPoint(hrp.Position)

                        GetPartPos = function(partName)
                            local part = char:FindFirstChild(partName)
                            if part then
                                local pos, visible = _G.Camera:WorldToViewportPoint(part.Position)
                                return Vector2.new(pos.X, pos.Y), visible
                            end
                        end

                        UpdateLine = function(line, fromPart, toPart)
                            local from, fVis = GetPartPos(fromPart)
                            local to, tVis = GetPartPos(toPart)
                            if from and to and fVis and tVis then
                                line.From = from
                                line.To = to
                                line.Color = skeletonESPColor
                                line.Visible = true
                            else
                                line.Visible = false
                            end
                        end

                        if onScreen then
                            UpdateLine(limbs.Head_UpperTorso, "Head", "UpperTorso")
                            UpdateLine(limbs.UpperTorso_LowerTorso, "UpperTorso", "LowerTorso")
                            UpdateLine(limbs.UpperTorso_LeftUpperArm, "UpperTorso", "LeftUpperArm")
                            UpdateLine(limbs.LeftUpperArm_LeftLowerArm, "LeftUpperArm", "LeftLowerArm")
                            UpdateLine(limbs.LeftLowerArm_LeftHand, "LeftLowerArm", "LeftHand")
                            UpdateLine(limbs.UpperTorso_RightUpperArm, "UpperTorso", "RightUpperArm")
                            UpdateLine(limbs.RightUpperArm_RightLowerArm, "RightUpperArm", "RightLowerArm")
                            UpdateLine(limbs.RightLowerArm_RightHand, "RightLowerArm", "RightHand")
                            UpdateLine(limbs.LowerTorso_LeftUpperLeg, "LowerTorso", "LeftUpperLeg")
                            UpdateLine(limbs.LeftUpperLeg_LeftLowerLeg, "LeftUpperLeg", "LeftLowerLeg")
                            UpdateLine(limbs.LeftLowerLeg_LeftFoot, "LeftLowerLeg", "LeftFoot")
                            UpdateLine(limbs.LowerTorso_RightUpperLeg, "LowerTorso", "RightUpperLeg")
                            UpdateLine(limbs.RightUpperLeg_RightLowerLeg, "RightUpperLeg", "RightLowerLeg")
                            UpdateLine(limbs.RightLowerLeg_RightFoot, "RightLowerLeg", "RightFoot")
                        else
                            for _, line in pairs(limbs) do
                                line.Visible = false
                            end
                        end
                    else
                        for _, line in pairs(limbs) do
                            line.Visible = false
                        end
                    end
                end))

                PlayerESP[plr] = {limbs = limbs, connection = connection}
            end

            _G.Players.PlayerAdded:Connect(function(plr)
                plr.CharacterAdded:Connect(function()
                    task.wait(1)
                    DrawESP(plr)
                end)
            end)

            for _, plr in ipairs(_G.Players:GetPlayers()) do
                if plr ~= _G.Player then
                    plr.CharacterAdded:Connect(function()
                        task.wait(1)
                        DrawESP(plr)
                    end)
                    if plr.Character then
                        DrawESP(plr)
                    end
                end
            end

            _G.Players.PlayerRemoving:Connect(function(plr)
                ClearESP(plr)
            end)
        else
            ESP_Enabled = false
            for _, plr in pairs(PlayerESP) do
                ClearESP(plr)
            end
        end
    end
}):AddColorPicker('Skeleton Color', {
    Text = 'Skeleton ESP Color',
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(color)
        skeletonESPColor = color
    end
})

    _G.CorpseESPEnabled = _G.CorpseESPEnabled or false
    _G.CorpseESPMaxDistance = _G.CorpseESPMaxDistance or 500
    _G.CorpseESPColor = _G.CorpseESPColor or Color3.fromRGB(255, 255, 255)

    ESP:AddToggle('Corpse ESP', {
    Text = 'Corpse ESP',
    Default = _G.CorpseESPEnabled,
    Callback = function(state)
        _G.CorpseESPEnabled = state
    end
}):AddColorPicker('CorpseESPColor', {
    Text = 'Corpse ESP Color',
    Default = _G.CorpseESPColor,
    Callback = function(color)
        _G.CorpseESPColor = color
    end
})

ESP:AddSlider('CorpseESPDistance', {
    Text = 'ESP Max Distance',
    Default = _G.CorpseESPMaxDistance,
    Min = 50,
    Max = 800,
    Rounding = 1,
    Callback = function(value)
        _G.CorpseESPMaxDistance = value
    end
})

function _G.AddCorpseESP(Corpse)
    local Text1 = Drawing.new("Text")
    Text1.Visible = false
    Text1.Center = true
    Text1.Outline = true
    Text1.Font = 2
    Text1.Size = 12

    local Text2 = Drawing.new("Text")
    Text2.Visible = false
    Text2.Center = true
    Text2.Outline = true
    Text2.Font = 2
    Text2.Size = 12

    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera
    local LocalPlayer = game.Players.LocalPlayer

    local connection
    connection = RunService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
        if not _G.CorpseESPEnabled then
            Text1.Visible = false
            Text2.Visible = false
            return
        end

        if Corpse and Corpse:FindFirstChildOfClass("Humanoid") then
            local Humanoid = Corpse:FindFirstChildOfClass("Humanoid")
            if Humanoid.Health == 0 then
                local part = Corpse:FindFirstChildOfClass("MeshPart") or Corpse:FindFirstChild("HumanoidRootPart")
                if part then
                    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local dist = root and (part.Position - root.Position).Magnitude or math.huge
                    if dist <= _G.CorpseESPMaxDistance then
                        local pos, onscreen = Camera:WorldToViewportPoint(part.Position)
                        if onscreen and pos.Z > 0 then
                            Text1.Position = Vector2.new(pos.X, pos.Y)
                            Text2.Position = Vector2.new(pos.X, pos.Y + 15)

                            Text1.Text = Corpse.Name .. "'s Corpse"
                            Text2.Text = tostring(math.round(dist / 3)) .. "m"

                            Text1.Color = _G.CorpseESPColor
                            Text2.Color = _G.CorpseESPColor

                            Text1.Visible = true
                            Text2.Visible = true
                        else
                            Text1.Visible = false
                            Text2.Visible = false
                        end
                    else
                        Text1.Visible = false
                        Text2.Visible = false
                    end
                end
            else
                Text1.Visible = false
                Text2.Visible = false
                Text1:Remove()
                Text2:Remove()
                connection:Disconnect()
            end
        else
            Text1.Visible = false
            Text2.Visible = false
        end
    end))
end

for _, obj in ipairs(workspace:GetChildren()) do
    if obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") then
        _G.AddCorpseESP(obj)
    end
end

workspace.DescendantAdded:Connect(function(child)
    task.wait(1)
    if child:IsA("Model") and child:FindFirstChildOfClass("Humanoid") then
        _G.AddCorpseESP(child)
    end
end)

_G.Skins = _G.Skins or {
    ["762x25MAG"] = "Nutcracker",
    ["762x25Rnd71Mag"] = "Arctic",
    ["762x25TTMAG"] = "Watergun",
    ["762x39MAG"] = "DeltaAnime",
    ["762x39Rnd75Mag"] = "Anton",
    ["762x54Rnd10Mag"] = "Permafrost",
    ["9x18vzMag"] = "GiftWrap",
    ["9x19MP443MAG"] = "JollyRoger",
    ["9x19MP5MAG"] = "Permafrost",
    ["9x39Mag"] = "Shoreline",
    AKMN = "DeltaAnime",
    FrontAKMN = "DeltaAnime",
    HandleRK3AKMN = "DeltaAnime",
    PolymerStockAKMN = "DeltaAnime",
    HandleAKMN = "Valentine",
    TacticalFrontAKMN = "AnodizedRed",
    MuzzleBrakeAKM = "AnodizedRed",
    CombatGloves = "Anarchy",
    CamoShirt = "Anarchy",
    HandWraps = "SantaCommando",
    WastelandShirt = "SantaCommando",
    M4 = "Devil",
    Lighter = "EarlyAccess",
    GorkaShirt = "Wetsuit",
    GhillieTorso = "Arctic",
    AsVal = "Shoreline",
    F1 = "Pineapple",
    Makarov = "Serpant",
    Mosin = "SkullHunter",
    PPSH41 = "Nutcracker",
    SVD = "Permafrost",
    Saiga12 = "Valentine",
    TT33 = "Watergun",
    ZSh = "Woodland",
    MP5SD = "Permafrost",
    MP443 = "Whiteout",
    IZh81 = "Watergun",
}

_G.SkinChangerEnabled = _G.SkinChangerEnabled or false

function _G.ChangeSkins()
    while _G.SkinChangerEnabled do
        task.wait(1)

        local RepStorage = game:GetService("ReplicatedStorage")
        local ViewModels = RepStorage:FindFirstChild("ViewModels")
        if ViewModels then
            local DV2 = ViewModels:FindFirstChild("DV2")
            local Karambit = ViewModels:FindFirstChild("PlasmaNinjato")

            if DV2 and Karambit then
                DV2.Name = "DV2real"
                Karambit.Name = "DV2"
            end
        end

        local playersFolder = RepStorage:FindFirstChild("Players")
        if playersFolder then
            local plrData = playersFolder:FindFirstChild(game.Players.LocalPlayer.Name)
            if plrData then
                for _, v in ipairs(plrData:GetDescendants()) do
                    if v:FindFirstChild("ItemProperties") and _G.Skins[v.Name] then
                        v.ItemProperties:SetAttribute("Skin", _G.Skins[v.Name])
                    end
                end
            end
        end
    end
end

    ESP:AddToggle('enableSkinChanger', { 
    Text = 'Skin Changer', 
    Default = _G.SkinChangerEnabled,               
    Callback = function(state)
        _G.SkinChangerEnabled = state
        print("Skin Changer " .. (state and "Enabled" or "Disabled"))
        if state then
            task.spawn(_G.ChangeSkins)
        end
    end
})

_G.ExtractESPSettings = _G.ExtractESPSettings or {
    Enabled = false,
    ShowDistance = false,
    MaxDistance = 0,
    Color = Color3.fromRGB(255, 0, 0),
    Size = 13
}

_G.ExtractESPDrawings = _G.ExtractESPDrawings or {}
_G.ProcessedExtracts = _G.ProcessedExtracts or {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

function _G.ToggleExtract(state)
    _G.ExtractESPSettings.Enabled = state
end

function _G.ToggleExtractDistance(state)
    _G.ExtractESPSettings.ShowDistance = state
end

    ESP:AddToggle('Extract', {
    Text = 'Extract',
    Default = false,
    Callback = function(state)
        _G.ToggleExtract(state)
    end
}):AddColorPicker('ExtractColor', {
    Default = _G.ExtractESPSettings.Color,
    Title = 'Extract Color',
    Callback = function(Value)
        _G.ExtractESPSettings.Color = Value
    end
})

    ESP:AddToggle('ExtractDistance', {
    Text = 'Extract Distance',
    Default = false,
    Callback = function(state)
        _G.ToggleExtractDistance(state)
    end
})

function _G.AddExtractEsp(Extract)
    if not Extract or not Extract:IsDescendantOf(Workspace) or _G.ProcessedExtracts[Extract] then return end
    if Extract.Name ~= "Exit" then return end

    _G.ProcessedExtracts[Extract] = true

    local part = Extract:IsA("Model") and Extract.PrimaryPart or Extract:IsA("BasePart") and Extract or nil
    if not part then return end

    local text = Drawing.new("Text")
    text.Visible = false
    text.Center = true
    text.Outline = true
    text.Font = 3
    text.Size = _G.ExtractESPSettings.Size

    _G.ExtractESPDrawings[Extract] = text

    local function update()
        if not _G.ExtractESPSettings.Enabled or not Extract:IsDescendantOf(Workspace) then
            text.Visible = false
            return
        end

        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then
            text.Visible = false
            return
        end

        local dist = (part.Position - hrp.Position).Magnitude
        if _G.ExtractESPSettings.MaxDistance > 0 and dist > _G.ExtractESPSettings.MaxDistance then
            text.Visible = false
            return
        end

        local screenPos, onScreen = Workspace.CurrentCamera:WorldToViewportPoint(part.Position)
        if onScreen then
            text.Position = Vector2.new(screenPos.X, screenPos.Y)
            text.Text = _G.ExtractESPSettings.ShowDistance and ("Exit [" .. math.round(dist / 3) .. "m]") or "Exit"
            text.Color = _G.ExtractESPSettings.Color
            text.Visible = true
        else
            text.Visible = false
        end
    end

    local render = RunService.Heartbeat:Connect(update)

    Extract.AncestryChanged:Connect(function(_, parent)
        if not parent then
            text:Remove()
            render:Disconnect()
            _G.ExtractESPDrawings[Extract] = nil
            _G.ProcessedExtracts[Extract] = nil
        end
    end)
end

function _G.RemoveExtract(Extract)
    if _G.ProcessedExtracts[Extract] then
        local drawing = _G.ExtractESPDrawings[Extract]
        if drawing then drawing:Remove() end
        _G.ExtractESPDrawings[Extract] = nil
        _G.ProcessedExtracts[Extract] = nil
    end
end

function _G.RefreshExtracts()
    for extract, drawing in pairs(_G.ExtractESPDrawings) do
        if drawing then drawing:Remove() end
    end
    _G.ExtractESPDrawings = {}
    _G.ProcessedExtracts = {}

    local exitParent = Workspace:FindFirstChild("NoCollision") and Workspace.NoCollision:FindFirstChild("ExitLocations")
    if exitParent then
        for _, obj in pairs(exitParent:GetDescendants()) do
            if obj.Name == "Exit" then
                _G.AddExtractEsp(obj)
            end
        end

        if not _G.ProcessedExtracts["DescendantConnection"] then
            _G.ProcessedExtracts["DescendantConnection"] = true

            exitParent.DescendantAdded:Connect(function(obj)
                task.wait(0.05)
                if obj.Name == "Exit" then
                    _G.AddExtractEsp(obj)
                end
            end)

            exitParent.DescendantRemoving:Connect(function(obj)
                if obj.Name == "Exit" then
                    _G.RemoveExtract(obj)
                end
            end)
        end
    end
end

_G.RefreshExtracts()
	
    local TweenService = game:GetService("TweenService")
    local hitmarkbool = false
    local hitmarkcolor = Color3.fromRGB(255, 255, 255)
    local hitmarkfade = 2

    ESP:AddToggle('Hit Markers', {
        Text = 'Hit Markers',
        Default = false,
        Tooltip = '',
        Callback = function(v)
            hitmarkbool = v
            _G.HitmarkersEnabled = v
        end
    }):AddColorPicker('Hitmark color', {
        Default = Color3.new(1, 1, 1),
        Title = 'Hitmark color',
        Transparency = nil,
        Callback = function(color)
            hitmarkcolor = color
            _G.HitmarkerColor = color 
        end
    })
    ESP:AddSlider('Hit Marker Time', {
        Text = 'Hit Marker Time',
        Default = 2,
        Min = 0,
        Max = 10,
        Rounding = 1,
        Compact = false,
        Callback = function(c)
            hitmarkfade = c
            _G.HitmarkerFade = c 
        end
    })    

    _G.HitmarkersEnabled = true
    _G.HitmarkerColor = Color3.fromRGB(255, 255, 255)
    _G.HitmarkerFade = 2

if not workspace:FindFirstChild("NoCollision") then
    local folder = Instance.new("Folder")
    folder.Name = "NoCollision"
    folder.Parent = workspace
end

_G.showHitmarker = function(pos)
    local hitpart = Instance.new("Part")
    hitpart.Name = "HitmarkerPart"
    hitpart.Transparency = 1
    hitpart.CanCollide = false
    hitpart.CanQuery = false
    hitpart.Size = Vector3.new(0.01, 0.01, 0.01)
    hitpart.Anchored = true
    hitpart.Position = pos
    hitpart.Parent = workspace:FindFirstChild("NoCollision")

    local hit = Instance.new("BillboardGui")
    hit.Name = "hit"
    hit.AlwaysOnTop = true
    hit.Size = UDim2.new(0, 80, 0, 80) 
    hit.StudsOffset = Vector3.new(0, 0, 0)
    hit.Parent = hitpart

    local hit_img = Instance.new("ImageLabel")
    hit_img.Name = "hit_img"
    hit_img.Image = "http://www.roblox.com/asset/?id=13298929624"
    hit_img.BackgroundTransparency = 1
    hit_img.Size = UDim2.new(0, 80, 0, 80) 
    hit_img.Visible = true
    hit_img.ImageColor3 = _G.HitmarkerColor
    hit_img.Rotation = 45
    hit_img.AnchorPoint = Vector2.new(0.5, 0.5)
    hit_img.Position = UDim2.new(0.5, 0, 0.5, 0)
    hit_img.Parent = hit

    task.spawn(function()
        local ts = game:GetService("TweenService")
        ts:Create(hit_img, TweenInfo.new(_G.HitmarkerFade, Enum.EasingStyle.Sine), {ImageTransparency = 1}):Play()
        ts:Create(hit_img, TweenInfo.new(_G.HitmarkerFade, Enum.EasingStyle.Linear), {Rotation = 180}):Play()
        task.wait(_G.HitmarkerFade)
        if hitpart then hitpart:Destroy() end
    end)
end   
 
    local Lighting = game:GetService("Lighting")
    local RunService = game:GetService("RunService")

    getgenv().ClockSettings = {
    Enabled = false,
    Value = 14,
    Original = {
        Sky = Lighting:FindFirstChildOfClass("Sky"),
        Ambient = Lighting.Ambient,
        OutdoorAmbient = Lighting.OutdoorAmbient,
        Brightness = Lighting.Brightness
    }
}

local ClockSettings = getgenv().ClockSettings

local function ApplyNightSky()
    local existingSky = Lighting:FindFirstChildOfClass("Sky")
    if existingSky then existingSky:Destroy() end

    local sky = Instance.new("Sky")
    sky.Name = "CustomNightSky"
    sky.SkyboxBk = "rbxassetid://159454299"
    sky.SkyboxDn = "rbxassetid://159454296"
    sky.SkyboxFt = "rbxassetid://159454293"
    sky.SkyboxLf = "rbxassetid://159454286"
    sky.SkyboxRt = "rbxassetid://159454300"
    sky.SkyboxUp = "rbxassetid://159454288"
    sky.StarCount = 3000
    sky.Parent = Lighting
end

local function ApplyNightMode()
    Lighting.ClockTime = 0
    Lighting.Brightness = 1
    Lighting.OutdoorAmbient = Color3.new(0, 0, 0)
    Lighting.Ambient = Color3.new(0.04, 0.04, 0.04)

    local sun = Lighting:FindFirstChildOfClass("SunRaysEffect")
    if sun then sun:Destroy() end

    ApplyNightSky()
end

local function RestoreLighting()
    local custom = Lighting:FindFirstChild("CustomNightSky")
    if custom then custom:Destroy() end

    if ClockSettings.Original.Sky then ClockSettings.Original.Sky:Clone().Parent = Lighting end
    Lighting.Ambient = ClockSettings.Original.Ambient
    Lighting.OutdoorAmbient = ClockSettings.Original.OutdoorAmbient
    Lighting.Brightness = ClockSettings.Original.Brightness
end

    ESP:AddToggle("Clock Time", {
    Text = "Clock Time",
    Default = ClockSettings.Enabled,
    Tooltip = "Lock time to night and apply night visuals",
    Callback = function(state)
        ClockSettings.Enabled = state
        if state then
            ApplyNightMode()
        else
            RestoreLighting()
            Lighting.ClockTime = ClockSettings.Value
        end
    end
})

    ESP:AddSlider("Clock Time Slider", {
    Text = "Clock Time",
    Default = ClockSettings.Value,
    Min = 0,
    Max = 24,
    Rounding = 1,
    Compact = false,
    Callback = function(val)
        ClockSettings.Value = val
        if not ClockSettings.Enabled then
            Lighting.ClockTime = val
        end
    end
})

RunService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
    if ClockSettings.Enabled then
        Lighting.ClockTime = 0
    end
end))
    
    getgenv().ESPConfig = getgenv().ESPConfig or {
    espmapmarkers = {},
    espmapactive = false,
    aimFRIENDLIST = {},
}

    local ESPConfig = getgenv().ESPConfig

    ESP:AddToggle('ESP_Map_Toggle', {
    Text = 'ESP Map',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        if scriptloading then return end
        ESPConfig.espmapactive = v
        handleESPMAP(v)
    end
})

print("ESP MAP Enabled")
handleESPMAP = function(bool)
    if bool then
        local playerGui = game.Players.LocalPlayer.PlayerGui
        local mapFrame = playerGui.MainGui.MainFrame.MapFrame.MainFrame
        local map = mapFrame.Maps.EstonianBorderMap

        mapFrame.Size = UDim2.fromScale(1, 1)
        mapFrame.Position = UDim2.new(0.5, 0, 0.49, 0)
        mapFrame.Parent.Visible = true

        game.UserInputService.MouseIconEnabled = true
        playerGui.MainGui.ModalButton.Modal = true

        for _, v in ipairs(mapFrame.Markers:GetChildren()) do
            v:Destroy()
        end

        local selfMarker = mapFrame.MarkerDotTemplate:Clone()
        selfMarker.Name = "SelfMarker"
        selfMarker.Visible = true
        selfMarker.Parent = mapFrame.Markers
        selfMarker.TextLabel.Visible = true

        ESPConfig.espmapmarkers.Me = {
            playerRef = game.Players.LocalPlayer,
            markerRef = selfMarker,
        }

        for _, v in ipairs(game.Players:GetChildren()) do
            if v ~= game.Players.LocalPlayer then
                local plrMarker = mapFrame.MarkerDotTemplate:Clone()
                plrMarker.ImageColor3 = Color3.fromRGB(227, 36, 36)
                plrMarker.Name = "TeamMarker"
                plrMarker.Visible = true
                plrMarker.TextLabel.Text = v.Name
                plrMarker.TextLabel.Visible = true
                plrMarker.TextLabel.Size = UDim2.fromScale(2, 0.5)
                plrMarker.TextLabel.Position = UDim2.fromScale(-0.5, 0)
                plrMarker.Parent = mapFrame.Markers

                ESPConfig.espmapmarkers[v.Name] = {
                    playerRef = v,
                    markerRef = plrMarker,
                }
            end
        end
        
        task.spawn(function()
            while task.wait(0.1) do
                if not ESPConfig.espmapactive then return end

                for ind, markerData in pairs(ESPConfig.espmapmarkers) do
                    if markerData.markerRef == nil then
                        ESPConfig.espmapmarkers[ind] = nil
                    else
                        local playerRef = markerData.playerRef
                        if playerRef and playerRef.Character then
                            local chpos = game.ReplicatedStorage.Players:FindFirstChild(playerRef.Name).Status.UAC:GetAttribute("LastVerifiedPos")
                            if chpos then
                                local xPos = (chpos.X - 208) / map:GetAttribute("SizeReal")
                                local zPos = (chpos.Z + 203) / map:GetAttribute("SizeReal")
                                markerData.markerRef.Position = UDim2.new(0.5 + xPos, 0, 0.5 + zPos, 0)
                                markerData.markerRef.Visible = true
                                
                                if playerRef ~= game.Players.LocalPlayer then
                                    if table.find(ESPConfig.aimFRIENDLIST, playerRef.Name) then
                                        markerData.markerRef.ImageColor3 = Color3.fromRGB(102, 245, 66) -- Friend color
                                    else
                                        markerData.markerRef.ImageColor3 = Color3.fromRGB(227, 36, 36) -- Enemy color
                                    end
                                end
                            else
                                markerData.markerRef.Visible = false
                            end
                        else
                            markerData.markerRef.Visible = false
                        end
                    end
                end
            end
        end)

        mapFrame.Markers.Visible = true
    else
        if game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.Visible then
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.Visible = false
            game.Players.LocalPlayer.PlayerGui.MainGui.ModalButton.Modal = false
            game.UserInputService.MouseIconEnabled = false
        end
    end
end

local userInputService = game:GetService("UserInputService")
userInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.M then
        ESPConfig.espmapactive = not ESPConfig.espmapactive
        handleESPMAP(ESPConfig.espmapactive)
    end
end)

shared.viewmod_materials = {
    ["Plastic"] = Enum.Material.SmoothPlastic,
    ["Neon"] = Enum.Material.Neon,
    ["Forcefield"] = Enum.Material.ForceField,
    ["Metal"] = Enum.Material.Metal,
    ["DiamondPlate"] = Enum.Material.DiamondPlate,
    ["Granite"] = Enum.Material.Granite,
    ["Marble"] = Enum.Material.Marble,
    ["Slate"] = Enum.Material.Slate,
    ["Cobblestone"] = Enum.Material.Cobblestone,
    ["Wood"] = Enum.Material.Wood,
    ["WoodPlanks"] = Enum.Material.WoodPlanks,
    ["Cherry Fizz"] = Enum.Material.Brick,
    ["Concrete"] = Enum.Material.Concrete,
    ["Ice"] = Enum.Material.Ice,
    ["Sand"] = Enum.Material.Sand,
    ["Fabric"] = Enum.Material.Fabric,
    ["Asphalt"] = Enum.Material.Asphalt,
    ["CorrodedMetal"] = Enum.Material.CorrodedMetal,
}

    _G.viewmodbool = false
    _G.viewmodhandmat = Enum.Material.Plastic
    _G.viewmodgunmat = Enum.Material.Plastic
    _G.viewmodhandcolor = Color3.fromRGB(255, 255, 255)
    _G.viewmodguncolor = Color3.fromRGB(255, 255, 255)

    _G.gunRainbowEnabled = false
    _G.handRainbowEnabled = false
    _G.lastUpdate = 0

    ESP:AddToggle('Texture Changer', { 
    Text = 'Hand And Gun Chams',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        _G.viewmodbool = v
    end
})

    ESP:AddDropdown('Hand Material', {
    Values = {'Neon', 'Forcefield', 'Plastic'},
    Default = 'Plastic',
    Multi = false,
    Callback = function(a)
        _G.viewmodhandmat = shared.viewmod_materials[a] or _G.viewmodhandmat
    end
})

    ESP:AddDropdown('Gun Material', {
    Values = {'Neon', 'Forcefield', 'Plastic'},
    Default = 'Plastic',
    Multi = false,
    Callback = function(a)
        _G.viewmodgunmat = shared.viewmod_materials[a] or _G.viewmodgunmat
    end
})

    ESP:AddLabel('Hand Color'):AddColorPicker('HandColorPicker', {
    Default = Color3.new(1, 1, 1),
    Title = 'Color Of The Hand',
    Transparency = nil,
    Callback = function(a)
        _G.viewmodhandcolor = a
    end
})

    ESP:AddLabel('Gun Color'):AddColorPicker('GunColorPicker', {
    Default = Color3.new(1, 1, 1),
    Title = 'Color Of The Gun',
    Transparency = nil,
    Callback = function(a)
        _G.viewmodguncolor = a
    end
})

    ESP:AddToggle('Gun Rainbow', {
    Text = 'Enable Gun Rainbow',
    Default = false,
    Tooltip = 'Cycle gun color through rainbow colors.',
    Callback = function(v)
        _G.gunRainbowEnabled = v
    end
})

    ESP:AddToggle('Hand Rainbow', {
    Text = 'Enable Hand Rainbow',
    Default = false,
    Tooltip = 'Cycle hand color through rainbow colors.',
    Callback = function(v)
        _G.handRainbowEnabled = v
    end
})

_G.getRainbowColor = function()
    local t = tick() * 2
    return Color3.fromRGB(
        math.floor(math.sin(t) * 127 + 128),
        math.floor(math.sin(t + 2) * 127 + 128),
        math.floor(math.sin(t + 4) * 127 + 128)
    )
end

_G.adjustNeonBrightness = function(color, factor)
    return Color3.new(
        math.clamp(color.R * factor, 0, 1),
        math.clamp(color.G * factor, 0, 1),
        math.clamp(color.B * factor, 0, 1)
    )
end

local wcamera = game.Workspace.CurrentCamera

_G.handleViewModel = function()
    if tick() - _G.lastUpdate < 0.1 then return end
    _G.lastUpdate = tick()

    if _G.viewmodbool and wcamera:FindFirstChild("ViewModel") then
        for _, obj in pairs(wcamera.ViewModel:GetDescendants()) do
            if obj:IsA("BasePart") then
                local mb = obj:FindFirstChildOfClass("SurfaceAppearance")
                if mb then mb:Destroy() end

                if not obj:FindFirstAncestor("Item") then
                    obj.Material = _G.viewmodhandmat
                    obj.Color = _G.handRainbowEnabled and _G.getRainbowColor() or _G.viewmodhandcolor
                else
                    obj.Material = _G.viewmodgunmat
                    if obj.Material == Enum.Material.Neon then
                        obj.Color = _G.gunRainbowEnabled and _G.getRainbowColor() or _G.adjustNeonBrightness(_G.viewmodguncolor, 0.65) 
                    else
                        obj.Color = _G.gunRainbowEnabled and _G.getRainbowColor() or _G.viewmodguncolor
                    end
                end
            end
        end
    end
end

game:GetService("RunService").Heartbeat:Connect(_G.handleViewModel)

	ESP:AddDivider()
	
	local Misc = Tabs.Misc:AddLeftGroupbox('Movement Mods')
	Misc:AddDivider()
    Misc:AddToggle('SpeedHacks', {
    Text = 'SpeedHacks', 
    Default = false, 
    Tooltip = '', 
    Callback = function(v)
        changerbool = v
    end
})

    Misc:AddSlider('SpeedHack Speed', {
    Text = 'Speed', 
    Default = 20, 
    Min = 0, 
    Max = 21, 
    Rounding = 1, 
    Compact = false, 
    Callback = function(c)
        changerspeed = c
    end
})

    Misc:AddSlider('Player JumpHeight', {
    Text = 'JumpHeight', 
    Default = 3, 
    Min = 0, 
    Max = 8, 
    Rounding = 1, 
    Compact = false, 
    Callback = function(c)
        if c then
            changerjump = c
        end
    end
})

    Misc:AddSlider('Player Height', {
    Text = 'Height', 
    Default = 2, 
    Min = -6, 
    Max = 6, 
    Rounding = 1, 
    Compact = false, 
    Callback = function(c)
        if c then
            changerheight = c
        end
    end
})

    Misc:AddSlider('Gravity', {
    Text = 'Gravity', 
    Default = 75, 
    Min = 0, 
    Max = 150, 
    Rounding = 1, 
    Compact = false, 
    Callback = function(c)
        if c then
            changergrav = c
        end
    end
})

print("loading speedhack function")

function startspeedhack()
    local speaker = game:GetService("Players").LocalPlayer
    local chr = speaker.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
    local hb = game:GetService("RunService").Heartbeat

    while changerbool and chr and hum and hum.Parent do
        local delta = hb:Wait()

        if hum.MoveDirection.Magnitude > 0 then
            chr:TranslateBy(hum.MoveDirection * tonumber(changerspeed) * delta * 10)
        else
            chr:TranslateBy(hum.MoveDirection * delta * 10)
        end
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if changerbool and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoid = game.Players.LocalPlayer.Character.Humanoid
        humanoid.WalkSpeed = changerspeed
        humanoid.JumpHeight = changerjump or 3  
        humanoid.HipHeight = changerheight or 2  
        workspace.Gravity = changergrav or 75  
    end
end)

if changerbool then
    startspeedhack()
end


getgenv().allvars = getgenv().allvars or {}
getgenv().runs = game:GetService("RunService")
getgenv().uis = game:GetService("UserInputService")
getgenv().Players = game:GetService("Players")
getgenv().localplayer = Players.LocalPlayer
getgenv().wcamera = workspace.CurrentCamera

if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") then
    localplayer.CharacterAdded:Wait()
    repeat task.wait() until localplayer.Character:FindFirstChild("HumanoidRootPart")
end

getgenv().charsemifly = false
allvars.charsemiflydist = 16
allvars.charsemiflyspeed = 30
getgenv().semifly_bodyvel = nil
getgenv().semifly_pos = CFrame.new()
getgenv().semifly_posconnect = nil

Misc:AddLabel('Fly'):AddKeyPicker('Fly Keybind', {
    Default = 'KeypadFive',
    SyncToggleState = false,
    Mode = 'Toggle', -- Always, Toggle, Hold
    Text = 'Fly',
    NoUI = false, 
    Callback = function(v)
        if scriptloading then return end

        if localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart") then
            if ACBYPASS_SYNC == false then
                Library:Notify("Action in queue, wait for anticheat bypass update", 4)
                while ACBYPASS_SYNC == false do
                    task.wait(0.5)
                end
            end

            if v == false then
                if semifly_bodyvel then
                    semifly_bodyvel:Destroy()
                end

                for _,obj in pairs(localplayer.Character.HumanoidRootPart:GetChildren()) do
                    if obj:IsA("BodyVelocity") then
                        obj:Destroy()
                    end
                end

                localplayer.Character.Humanoid.PlatformStand = false
            elseif v == true then
                semifly_bodyvel = Instance.new("BodyVelocity", localplayer.Character.HumanoidRootPart)
                semifly_bodyvel.Velocity = Vector3.new(0,0,0)
                semifly_bodyvel.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                localplayer.Character.Humanoid.PlatformStand = true
            end

            charsemifly = v
        else
            charsemifly = false
        end
    end,
    ChangedCallback = function(New)
    end
})

Misc:AddSlider('Fly Distance', {
    Text = 'Fly Distance',
    Default = 6,
    Min = 0.1,
    Max = 16,
    Rounding = 1,
    Compact = false,
    Callback = function(c)
        allvars.charsemiflydist = c
    end
})

Misc:AddSlider('Fly Speed', {
    Text = 'Fly Speed',
    Default = 30,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Callback = function(c)
        allvars.charsemiflyspeed = c
    end
})

runs.RenderStepped:Connect(function(delta)
    if charsemifly and localplayer.Character and ACBYPASS_SYNC == true then
        local hrp = localplayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local dir = Vector3.new(0, 0, 0)

        if uis:IsKeyDown(Enum.KeyCode.W) then
            dir += wcamera.CFrame.LookVector
        elseif uis:IsKeyDown(Enum.KeyCode.S) then
            dir -= wcamera.CFrame.LookVector
        end

        if uis:IsKeyDown(Enum.KeyCode.A) then
            dir -= wcamera.CFrame.RightVector
        elseif uis:IsKeyDown(Enum.KeyCode.D) then
            dir += wcamera.CFrame.RightVector
        end

        if uis:IsKeyDown(Enum.KeyCode.Space) then
            dir += Vector3.new(0, 1, 0)
        elseif uis:IsKeyDown(Enum.KeyCode.LeftShift) then
            dir -= Vector3.new(0, 1, 0)
        end

        local closest = fly_getclosestpoint()
        if closest then
            local d = (hrp.Position - closest).Magnitude
            if d > allvars.charsemiflydist then
                local ldir = (hrp.Position - closest).Unit * allvars.charsemiflydist
                local offset = fly_getoffset(ldir)
                hrp.CFrame = CFrame.new(closest + ldir - offset)
            else
                fly_move(dir * allvars.charsemiflyspeed * runs.RenderStepped:Wait(), delta)
            end
        else
            fly_move(dir * allvars.charsemiflyspeed * runs.RenderStepped:Wait(), delta)
        end
    end
end)

print("loaded successfully.")

function fly_move(dir)
    local hrp = localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local newPos = hrp.CFrame + (dir * 1)
    hrp.CFrame = newPos
end

function fly_getclosestpoint()
    local hrp = localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local dirs = {
        Vector3.new(1,0,0), Vector3.new(-1,0,0),
        Vector3.new(0,1,0), Vector3.new(0,-1,0),
        Vector3.new(0,0,1), Vector3.new(0,0,-1),
        Vector3.new(1,1,0), Vector3.new(1,-1,0),
        Vector3.new(-1,1,0), Vector3.new(-1,-1,0),
        Vector3.new(1,0,1), Vector3.new(1,0,-1),
        Vector3.new(-1,0,1), Vector3.new(-1,0,-1),
        Vector3.new(0,1,1), Vector3.new(0,1,-1),
        Vector3.new(0,-1,1), Vector3.new(0,-1,-1),
        Vector3.new(1,1,1), Vector3.new(1,1,-1),
        Vector3.new(1,-1,1), Vector3.new(1,-1,-1),
        Vector3.new(-1,1,1), Vector3.new(-1,1,-1),
        Vector3.new(-1,-1,1), Vector3.new(-1,-1,-1)
    }

    local fcp, cd = nil, math.huge
    local ignorl = {localplayer.Character, wcamera}

    for _, player in pairs(game.Players:GetPlayers()) do
        if player.Character then
            table.insert(ignorl, player.Character)
        end
    end

    for _, dir in pairs(dirs) do
        local ray = Ray.new(hrp.Position, dir * 200)
        local part, pos = workspace:FindPartOnRayWithIgnoreList(ray, ignorl)
        if part and pos then
            local d = (hrp.Position - pos).Magnitude
            if d < cd then
                cd = d
                fcp = pos
            end
        end
    end

    return fcp
end

function fly_getoffset(dir)
    local offset = Vector3.new(0.1, 0.1, 0.1)
    if dir.X > 0 then
        offset = Vector3.new(0.1, 0, 0)
    elseif dir.X < 0 then
        offset = Vector3.new(-0.1, 0, 0)
    elseif dir.Y > 0 then
        offset = Vector3.new(0, 0.1, 0)
    elseif dir.Y < 0 then
        offset = Vector3.new(0, -0.1, 0)
    elseif dir.Z > 0 then
        offset = Vector3.new(0, 0, 0.1)
    elseif dir.Z < 0 then
        offset = Vector3.new(0, 0, -0.1)
    end
    return offset
end

    Players = game:GetService("Players")
    RunService = game:GetService("RunService")
    LocalPlayer = Players.LocalPlayer
    projectDeltaPlaceId = 7336302630
    character = nil

    Misc:AddToggle('Silent Steps', {
    Text = 'Silent Steps', 
    Default = false, 
    Tooltip = '', 
    Callback = function(state)
        if state then
            initialize()
        else
            print("Silent Steps Disabled")
        end
    end
})

function disableFootsteps(character)
    if not character then return end
    local humanoid = character:WaitForChild("Humanoid", 5)
    if not humanoid then return end

    for _, descendant in pairs(character:GetDescendants()) do
        if descendant:IsA("Sound") and (descendant.Name:lower():find("walk") or descendant.Name:lower():find("run")) then
            descendant.Volume = 0
            descendant:Stop()
        end
    end

    character.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Sound") and (descendant.Name:lower():find("walk") or descendant.Name:lower():find("run")) then
            descendant.Volume = 0
            descendant:Stop()
        end
    end)
end

function initialize()
    if game.PlaceId == projectDeltaPlaceId then
        print("Footstep sound removal enabled.")
        
        if LocalPlayer.Character then
            disableFootsteps(LocalPlayer.Character)
        end

        LocalPlayer.CharacterAdded:Connect(function(char)
            wait(0.5) 
            disableFootsteps(char)
        end)
    end
end

    Misc:AddToggle('Remove landmines', {Text = 'Remove landmines', Default = false, Tooltip = '', Callback = function(state)
	if state then
		if workspace:FindFirstChild("AiZones") then
			local count = 0
		
			for i, v in next, workspace.AiZones:GetChildren() do
				local name = v.Name
				if name == "OutpostLandmines" or name == "OutpostClaymores" or name == "HeliCrashClaymores" then
					v:Destroy()
					count = count + 1
				end
			end
		
			if count > 0 then
				Library:Notify("Deleted " .. count ..  " landmines")
			else
				Library:Notify("No landmines detected")
			end
		else
			Library:Notify("No landmine category")
		end

	else
	print("bye nigger")
	end
	end})

    Misc:AddToggle('Remove Bridge IEDS', {
    Text = 'Remove Bridge IEDS',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        nobomb = v
        if nobomb then
            local targetFolder = workspace:FindFirstChild("AiZones")
            if targetFolder then
                local bridgeClaymores = targetFolder:FindFirstChild("BridgeClaymores")
                if bridgeClaymores then
                    bridgeClaymores:Destroy()
                    print("BridgeClaymores folder removed.")
                else
                    print("Removed")
                end
            else
                print("AiZones folder not found.")
            end
        end
    end
})

    local noieds = false

    Misc:AddToggle('Remove City13 IEDS', {
    Text = 'Remove City13 IEDS',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        noieds = v
        if noieds then
            removeIEDs()
        end
    end
})

function removeIEDs()
    local claymoreFolder = workspace:FindFirstChild("AiZones")
    if claymoreFolder then
        local claymores = claymoreFolder:FindFirstChild("Claymores")
        if claymores and claymores:IsA("Folder") then
            claymores:Destroy()
            print("Removed IEDS")
        else
            warn("Removed IEDS")
        end
    else
        warn("Removed IEDS")
    end
end

_G.WaterClear = _G.WaterClear or {
    Enabled = false,
    ClearRadius = Vector3.new(100, 100, 100)
}

function _G.WaterClear:ClearAroundPlayer()
    local char = game.Players.LocalPlayer.Character
    if not char then return end

    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    workspace.Terrain:ReplaceMaterialInTransform(
        root.CFrame,
        self.ClearRadius,
        Enum.Material.Water,
        Enum.Material.Air
    )
end

if not _G.WaterClear.Connection then
    _G.WaterClear.Connection = game:GetService("RunService").Heartbeat:Connect(function()
        if _G.WaterClear.Enabled then
            _G.WaterClear:ClearAroundPlayer()
        end
    end)
end

    Misc:AddToggle('Below Water Bypass', {
    Text = 'Below Water Bypass',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        _G.WaterClear.Enabled = state
    end
})

    local nofall = false
    local instafall = false
    local localplayer = game.Players.LocalPlayer
    local RunService = game:GetService("RunService")
    local workspace = game:GetService("Workspace")

    Misc:AddToggle('No Fall', {
    Text = 'No Fall',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        nofall = v
    end
})

    Misc:AddToggle('Instant Fall', {
    Text = 'Instant Fall', 
    Default = false,
    Tooltip = '',
    Callback = function(v)
        instafall = v
    end
})

RunService.Heartbeat:Connect(function()
    if not localplayer.Character or not localplayer.Character:FindFirstChild("Humanoid") or not localplayer.Character:FindFirstChild("HumanoidRootPart") then return end

    local hum = localplayer.Character.Humanoid
    local root = localplayer.Character.HumanoidRootPart
    local humstate = hum:GetState()

    if nofall and (humstate == Enum.HumanoidStateType.Freefall or humstate == Enum.HumanoidStateType.FallingDown) and root.AssemblyLinearVelocity.Y < -30 then
        hum:ChangeState(Enum.HumanoidStateType.Landed)

        if instafall then
            local rparams = RaycastParams.new()
            rparams.FilterDescendantsInstances = {localplayer.Character}
            rparams.FilterType = Enum.RaycastFilterType.Blacklist

            local fray = workspace:Raycast(root.Position, Vector3.new(0, -400, 0), rparams)
            if fray then
                root.CFrame = CFrame.new(fray.Position + Vector3.new(0, 3, 0))
            end
        end
    end
end)	
	
    local worldjesus = false
    local waterplatforms = Instance.new("Model")
    waterplatforms.Parent = workspace

    Misc:AddToggle('Jesus', {
    Text = 'Jesus',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        worldjesus = v
        if worldjesus then
            task.spawn(function()
                while worldjesus do
                    wait(0.01)  
                    local humanoidRootPart = localplayer.Character:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        local hitPart = workspace:Raycast(humanoidRootPart.Position, Vector3.new(0, -5, 0) + humanoidRootPart.CFrame.LookVector * 5, RaycastParams.new())
                        
                        if hitPart and hitPart.Material == Enum.Material.Water then
                            local clone = Instance.new("Part")
                            clone.Parent = waterplatforms
                            clone.Position = hitPart.Position
                            clone.Anchored = true
                            clone.CanCollide = true
                            clone.Size = Vector3.new(10, 0.2, 10)
                            clone.Transparency = 1  
                        end
                    end
                end
            end)
        else
            for _, platform in ipairs(waterplatforms:GetChildren()) do
                platform:Destroy()
            end
        end
    end
})

    local nojumptilt = false

    Misc:AddToggle('Nojumptilt', {
    Text = 'No jump tilt',
    Default = false,
    Tooltip = 'Removes jump tilt when jumping',
    Callback = function(state)
        nojumptilt = state
    end
})

    print("Loading")

do
    local mod = require(game.ReplicatedStorage.Modules.FPS)
    local ogfunc = mod.updateClient

    mod.updateClient = function(a1, a2, a3)
        local result1, result2, result3 = ogfunc(a1, a2, a3)

        if nojumptilt and a1 and a1.springs and a1.springs.jumpCameraTilt then
            a1.springs.jumpCameraTilt.Position = Vector3.new(0, 0, 0)
        end

        return result1, result2, result3
    end
end

	Misc:AddToggle('Water Damage Bypass', {
    Text = 'Water Damage Bypass',   
    Default = false,
    Tooltip = '',
    Callback = function(v)
        if v then
            if scriptloading then return end

            localplayer.PlayerGui.MainGui.Scripts.HealthLocal.Disabled = true
        else
            localplayer.PlayerGui.MainGui.Scripts.HealthLocal.Disabled = false
        end
    end
})

    local checkingPlayers = false
    local checkThread

    Misc:AddToggle('Check Player Loot', {
    Text = 'Check Player Loot',
    Default = false,
    Tooltip = 'Lists players who have high-value loot or gear.',
    Callback = function(state)
        checkingPlayers = state
        if state then
            local possibles = {
                "TFZ98S", "R700", "M4", "SOCOM556", "FlareGun",
                "GPU", "FastMT", "IOTV4", "HSPV", "Mag556Rnd100",
                "AsVal", "FastVisor", "JPC", "PKM", "QuadNVG",
                "Reapir", "SPSh44", "TitanShield", "Gold50g",
                "RedCard", "BlueCard"
            }

            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local LocalPlayer = Players.LocalPlayer

            if not ReplicatedStorage:FindFirstChild("ItemsList") or not ReplicatedStorage:FindFirstChild("Players") then
                warn("Could not find expected data folders inside ReplicatedStorage")
                return
            end
            local validatedList = {}
            for _, i in ipairs(possibles) do
                for _, l in ipairs(ReplicatedStorage.ItemsList:GetChildren()) do
                    if i:lower() == l.Name:lower() then
                        table.insert(validatedList, l.Name)
                        break
                    end
                end
            end
            checkThread = task.spawn(function()
                while checkingPlayers do
                    local results = {}
                    local foundCount = 0

                    for _, player in ipairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer then
                            local repInstance = ReplicatedStorage.Players:FindFirstChild(player.Name)
                            if not repInstance then
                                continue
                            end

                            local inv = repInstance:FindFirstChild("Inventory")
                            if not inv then
                                continue
                            end

                            local itemList = {}
                            for _, v in ipairs(inv:GetDescendants()) do
                                for _, wanted in ipairs(validatedList) do
                                    if v.Name:lower() == wanted:lower() then
                                        table.insert(itemList, v.Name)
                                    end
                                end
                            end

                            if #itemList > 0 then
                                foundCount += 1
                                results[player.Name] = itemList
                            end
                        end
                    end

                    if foundCount > 0 then
                        print("Players with high-value items:", foundCount)
                        for name, items in pairs(results) do
                            print(name .. " has: " .. table.concat(items, ", "))
                        end
                    else
                        print("No players with high-value loot found.")
                    end

                    task.wait(5)
                end
            end)
        else
            checkingPlayers = false
            if checkThread then
                task.cancel(checkThread)
                checkThread = nil
            end
            print("Stopped checking player loot.")
        end
    end
})

    local allvars = {
    upanglebool = false,
    upanglenum = 0,
    invisbool = false
}

    Misc:AddToggle('Anti Aim UpAngle', {
    Text = 'Anti Aim UpAngle',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        allvars.upanglebool = v
    end
})

    Misc:AddSlider('UpAngle Value', {
    Text = 'UpAngle Value',
    Default = 0,
    Min = -0.75,
    Max = 0.75,
    Rounding = 2, 
    Compact = false,
    Callback = function(c) 
        allvars.upanglenum = c
    end
})

local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}

    if Method == "FireServer" and self.Name == "UpdateTilt" then
        if allvars.upanglebool then
            Args[1] = allvars.upanglenum
            if allvars.invisbool then
                Args[1] = 0.75
            end
            return oldNamecall(self, table.unpack(Args))
        end
    end

    return oldNamecall(self, ...)
end)

setreadonly(mt, true)
	Misc:AddDivider()

	local Misc = Tabs.Misc:AddRightGroupbox('Local OP Mods')
	Misc:AddDivider()
	Misc:AddToggle('Force Hit', {Text = 'Force Hit', Default = false, Tooltip = '', Callback = function(state)
	if state then
    print('Enabled')       

	else
	print("State")
	end
	end})
	Misc:AddLabel('Keybind'):AddKeyPicker('AimbotToggle', {Default = 'MB2', SyncToggleState = false, Mode = 'Hold',Text = 'Keybind', NoUI = false, OnClick = function() ClickTic = tick(); end, ChangedCallback = function() end});

    Misc:AddToggle('Invis', {Text = 'Invis', Default = false, Tooltip = '', Callback = function(state)
	if state then
    print('Enabled')       

	else
	print("bye nigger")
	end
	end})
    Misc:AddLabel('InvisBind'):AddKeyPicker('InvisBind', {
        Default = 'C',
        SyncToggleState = false,
        Mode = 'Toggle',
        Text = 'Invis Key',
        NoUI = false,
        Callback = function() end
    })
    
    getgenv().animpos = 4.0 -- 2.3   -- new 4.2  
    getgenv().underground = 4.0  -- -2.0
    getgenv().xrotation = 90
    getgenv().upangle = 0
    getgenv().cameraOffset = Vector3.new(0, -1.4, -4)
    
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local runserv = game:GetService("RunService")
    local enabled = false
    local originalOffset = humanoid.CameraOffset
    local dysenc = {}
    
    local anim, track
    
    local function loadAnim()
        anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://15609995579"
        track = humanoid:LoadAnimation(anim)
        track:Play()
        track:AdjustSpeed(0)
    end
    
    local function toggleCameraOffset(enable)
        if humanoid then
            humanoid.CameraOffset = enable and getgenv().cameraOffset or originalOffset
        end
    end
    
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    
    mt.__namecall = newcclosure(function(self, ...)
        local Method = getnamecallmethod()
        local Args = { ... }
        if Method == "FireServer" and self.Name == "UpdateTilt" then
            Args[1] = getgenv().upangle
            return oldNamecall(self, table.unpack(Args))
        end
        return oldNamecall(self, ...)
    end)
    
    setreadonly(mt, true)
    
    local cameraMt = getrawmetatable(game)
    local oldIndex = cameraMt.__newindex
    setreadonly(cameraMt, false)
    
    cameraMt.__newindex = newcclosure(function(self, index, value)
        if tostring(self) == "Humanoid" and index == "CameraOffset" and enabled then
            return oldIndex(self, index, getgenv().cameraOffset)
        end
        return oldIndex(self, index, value)
    end)
    
    setreadonly(cameraMt, true)
    
    player:GetMouse().KeyDown:Connect(function(key)
        if key:lower() == Options.InvisBind.Value:lower() then
            enabled = not enabled
            if enabled then
                loadAnim()
                toggleCameraOffset(true)
            else
                if track then
                    track:Stop()
                    track:Destroy()
                    track = nil
                end
                if anim then
                    anim:Destroy()
                    anim = nil
                end
                toggleCameraOffset(false)
            end
        end
    end)
    
    runserv.Heartbeat:Connect(function()
        if enabled and character and rootPart then
            if track then
                track.TimePosition = getgenv().animpos
            end
    
            dysenc[1] = rootPart.CFrame
            dysenc[2] = rootPart.AssemblyLinearVelocity
    
            local spoofCFrame = rootPart.CFrame
                * CFrame.Angles(math.rad(getgenv().xrotation), 0, 0)
                + Vector3.new(0, getgenv().underground, 0)
    
            rootPart.CFrame = spoofCFrame
    
            runserv.RenderStepped:Wait()
    
            if character and rootPart then
                rootPart.CFrame = dysenc[1]
                rootPart.AssemblyLinearVelocity = dysenc[2]
            end
        end
    end)
    
    player.CharacterAdded:Connect(function(newChar)
        character = newChar
        humanoid = character:WaitForChild("Humanoid")
        rootPart = character:WaitForChild("HumanoidRootPart")
        originalOffset = humanoid.CameraOffset
    
        if enabled then
            loadAnim()
            toggleCameraOffset(true)
        end
    end)

    allvars.doublejump = false
    local candbjump = false
    local dbjumplast = 0
    local dbjumpdelay = 0.2

local jumpConn, stateConn, charAddedConn

local function setupStateConnection(char)
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    if stateConn then stateConn:Disconnect() end
    stateConn = humanoid.StateChanged:Connect(function(_, state)
        if not allvars.doublejump then return end
        if state == Enum.HumanoidStateType.Jumping then
            candbjump = true
            dbjumplast = tick()
        elseif state == Enum.HumanoidStateType.Landed then
            candbjump = false
        end
    end)
end

Misc:AddToggle('Infinite Jump', {
    Text = 'Infinite Jump',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        allvars.doublejump = v

        if not v then
            if jumpConn then jumpConn:Disconnect() end
            if stateConn then stateConn:Disconnect() end
            if charAddedConn then charAddedConn:Disconnect() end
            return
        end

        if not jumpConn then
            jumpConn = uis.JumpRequest:Connect(function()
                if not allvars.doublejump then return end
                local ctime = tick()
                if ctime - dbjumplast < dbjumpdelay then return end

                local state = localplayer.Character and localplayer.Character:FindFirstChildOfClass("Humanoid") and localplayer.Character.Humanoid:GetState()
                if state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall then
                    if candbjump then
                        localplayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                        candbjump = false
                        dbjumplast = ctime
                    end
                end
            end)
        end

        if localplayer.Character then
            setupStateConnection(localplayer.Character)
        end

        charAddedConn = localplayer.CharacterAdded:Connect(function(char)
            task.wait(1.5)
            setupStateConnection(char)
        end)
    end
}) 
	Misc:AddToggle('Magic Bullet', {Text = 'Magic Bullet', Default = false, Tooltip = '', Callback = function(state)
	if state then
	print("Enabled")

	else
	print("bye nigger")
	end
	end})
    local wallbangEnabled = false

    Misc:AddToggle('WallBang', {
	Text = 'WallBang',
	Default = false,
	Tooltip = 'Enables wall penetration modifier',
	Callback = function(state)
		wallbangEnabled = state
		if wallbangEnabled then
			print("WallBang enabled")
		else
			print("WallBang disabled")
		end
	end
})

    Misc:AddToggle('Broker Bypass', {
        Text = 'Broker Bypass',
        Default = false,
        Tooltip = '',
        Callback = function(state)
            if state then
                task.spawn(function()
                    local broker = workspace:FindFirstChild("TheBroker")
                    if broker then
                        if broker:GetAttribute("Hidden") ~= nil then
                            broker:SetAttribute("Hidden", false)
                            print("Broker has been unhidden.")
                        else
                            print("JIGGY")
                        end
                    else
                        print("JIGGY")
                    end
                end)            
            else
                print("Boss Bypass disabled.")
            end
        end
    })  
	Misc:AddToggle('Anti Drown', {
    Text = 'Anti Drown',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        if state then
            if not game:IsLoaded() then
                game.Loaded:Wait()
            end

            local replicatedStorage = game:GetService("ReplicatedStorage")
            local runService = game:GetService("RunService")
            local lighting = game:GetService("Lighting")

            local waterBlur = lighting:WaitForChild("WaterBlur")
            local drowningRemote = replicatedStorage:WaitForChild("Remotes"):WaitForChild("Drowning")

            if not _G.LuraphSDKLoaded then
                loadstring(game:HttpGet("https://raw.githubusercontent.com/Luraph/macrosdk/main/luraphsdk.lua"))()
                _G.LuraphSDKLoaded = true
            end

            local namecallHook
            namecallHook = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
                local method = getnamecallmethod()
                local args = { ... }

                if (method == "FireServer" or method == "fireServer") and self == drowningRemote and args[1] and typeof(args[1]) == "number" then
                    return
                end

                return namecallHook(self, ...)
            end))

            runService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function()
                if waterBlur.Enabled then
                    waterBlur.Enabled = false
                end
            end))

            if typeof(printconsole) == "function" then
                printconsole("anti-drown loaded")
            end
        else
            print("byyyyy")
        end
    end
})
	Misc:AddToggle('Disable Local Anticheat', {Text = 'AntiCheat Bypass', Default = false, Tooltip = '', Callback = function(state)
	if state then
if not game:IsLoaded() then
    game.Loaded:Wait()
end

    local LocalPlayer = game.Players.LocalPlayer
    local Humanoid = LocalPlayer.Character and LocalPlayer.Character:WaitForChild("Humanoid")

if not Humanoid then
    LocalPlayer.CharacterAdded:Wait()
    Humanoid = LocalPlayer.Character:WaitForChild("Humanoid")
end

local Connections = {
    {'CharacterController', Humanoid:GetPropertyChangedSignal("WalkSpeed")},
    {'CharacterController', Humanoid:GetPropertyChangedSignal("JumpHeight")},
    {'CharacterController', Humanoid:GetPropertyChangedSignal("HipHeight")},
    {'CharacterController', Workspace:GetPropertyChangedSignal("Gravity")},
    {'CharacterController', Humanoid.StateChanged},
    {'CharacterController', Humanoid.ChildAdded},
    {'CharacterController', Humanoid.ChildRemoved},
}

local function disableConnections()
    for _, Array in ipairs(Connections) do
        for _, Connection in ipairs(getconnections(Array[2])) do
            if type(Connection.Function) == "function" then
                local Info = debug.getinfo(Connection.Function)

                if Info and string.find(Info.source, Array[1]) then
                    print(string.format("Disabling '%s': %s", tostring(Connection.Function), tostring(Array[2])))
                    Connection:Disable()
                end
            end
        end
    end
end

disableConnections()

LocalPlayer.CharacterAdded:Connect(function(character)
    Humanoid = character:WaitForChild("Humanoid")
    disableConnections()
end)

	else
	print("what")
	end
	end})
    
    local blinkbool = false
    local blinktemp = false
    local blinkstop = false
    local blinktable = {}
    Misc:AddToggle('Anti Lock On', {
    Text = 'Anti Lock On',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        blinkbool = state

        if blinkbool then
            beam = Instance.new("Beam")
            beam.Name = "LineBeam"
            beam.Parent = workspace

            startpart = Instance.new("Part")
            startpart.CanCollide = false
            startpart.CanQuery = false
            startpart.Transparency = 0
            startpart.Material = Enum.Material.ForceField
            startpart.Color = Color3.fromRGB(255, 0, 0)
            startpart.Size = localplayer.Character.HumanoidRootPart.Size
            startpart.CFrame = localplayer.Character.HumanoidRootPart.CFrame
            startpart.Anchored = true
            startpart.Parent = workspace

            local endpart = localplayer.Character.HumanoidRootPart
            local attach0 = Instance.new("Attachment", startpart)
            local attach1 = Instance.new("Attachment", endpart)

            beam.Attachment0 = attach0
            beam.Attachment1 = attach1
            beam.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 0, 0))
            beam.Width0 = 0.1
            beam.Width1 = 0.1
            beam.FaceCamera = true
            beam.Transparency = NumberSequence.new(0)
            beam.LightEmission = 1

            task.spawn(function()
                while blinkbool and startpart and startpart.Parent do
                    task.wait()
                    local playerStatus = game.ReplicatedStorage.Players:FindFirstChild(localplayer.Name)
                    if playerStatus and playerStatus:FindFirstChild("Status") and playerStatus.Status:FindFirstChild("UAC") then
                        local posi = playerStatus.Status.UAC:GetAttribute("LastVerifiedPos")
                        if posi then
                            startpart.CFrame = CFrame.new(posi, posi + localplayer.Character.HumanoidRootPart.CFrame.LookVector)
                        end
                    end
                end
            end)
        else
            if startpart then
                startpart:Destroy()
                startpart = nil
            end
            if beam then
                beam:Destroy()
                beam = nil
            end
        end
    end
})

    Misc:AddToggle('Stop Antilock when Stop', {
    Text = 'Stop Antilock when Stop',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        blinkstop = v 
    end
})

runs.Heartbeat:Connect(function(delta)
    if blinkbool and localplayer.Character and localplayer.Character.HumanoidRootPart then
        local hrp = localplayer.Character.HumanoidRootPart

        if blinkstop and localplayer.Character.Humanoid.MoveDirection.Magnitude == 0 then
            return
        end

        blinktable[1] = hrp.CFrame
        blinktable[2] = hrp.AssemblyLinearVelocity

        if not blinktemp then
            hrp.Anchored = true
            blinktable[3] = hrp.CFrame
            runs.RenderStepped:Wait()
            hrp.Anchored = false
            hrp.CFrame = blinktable[1]
            hrp.AssemblyLinearVelocity = blinktable[2]
        else
            hrp.CFrame = blinktable[1]
        end
    end
end)

runs.Heartbeat:Connect(function(delta)
    if allvars.desyncbool and localplayer.Character and localplayer.Character.HumanoidRootPart then
        if allvars.invisbool and invistrack then
            invistrack:Stop()
            invistrack = localplayer.Character.Humanoid.Animator:LoadAnimation(invisanim)
            invistrack:Play(.01, 1, 0)
            invistrack.TimePosition = invisnum

            desynctable[1] = localplayer.Character.HumanoidRootPart.CFrame
            desynctable[2] = localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity
            local cf = localplayer.Character.HumanoidRootPart.CFrame
            local posoffset = Vector3.new(0,-2.55,0)
            local rotoffset = Vector3.new(90,0,0)
            local spoofedcf = cf * CFrame.new(posoffset) * CFrame.Angles(math.rad(rotoffset.X), math.rad(rotoffset.Y), math.rad(rotoffset.Z))
            desynctable[3] = spoofedcf
            localplayer.Character.HumanoidRootPart.CFrame = spoofedcf
            runs.RenderStepped:Wait()
            localplayer.Character.HumanoidRootPart.CFrame = desynctable[1]
            localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity = desynctable[2]
        else
            desynctable[1] = localplayer.Character.HumanoidRootPart.CFrame
            desynctable[2] = localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity
            local cf = localplayer.Character.HumanoidRootPart.CFrame
            local posoffset = allvars.desyncPos and Vector3.new(allvars.desynXp, allvars.desynYp, allvars.desynZp) or Vector3.new(0,0,0)
            local rotoffset = allvars.desyncOr and Vector3.new(allvars.desynXo, allvars.desynYo, allvars.desynZo) or Vector3.new(0,0,0)
            local spoofedcf = cf * CFrame.new(posoffset) * CFrame.Angles(math.rad(rotoffset.X), math.rad(rotoffset.Y), math.rad(rotoffset.Z))
            desynctable[3] = spoofedcf
            localplayer.Character.HumanoidRootPart.CFrame = spoofedcf
            runs.RenderStepped:Wait()
            localplayer.Character.HumanoidRootPart.CFrame = desynctable[1]
            localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity = desynctable[2]
        end
    end
end)

    local ResolverEnabled = false
    local Connection

    Misc:AddToggle('Manipulation', {
    Text = 'Manipulation (UAC ai)',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        ResolverEnabled = state
        if ResolverEnabled then
            local MouseInput = Enum.UserInputType.MouseButton1

            local Players = game:GetService("Players")
            local Workspace = game:GetService("Workspace")
            local UserInputService = game:GetService("UserInputService")
            local Player = Players.LocalPlayer

            local Velocity = 2800
            local Delay = 0.07
            local Offset = 38 --47 --37
            local Resolving = false

            Connection = UserInputService.InputBegan:Connect(function(Input, Processed)
                if not Processed and ResolverEnabled and not Resolving then
                    if Input.UserInputType == MouseInput then
                        Resolving = true
                        if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
                            local Character = Player.Character
                            local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
                            local Cached = HumanoidRootPart.CFrame

                            HumanoidRootPart.Velocity = Vector3.new(0, -Velocity, 0)
                            wait(Delay)
                            HumanoidRootPart.Anchored = true
                            HumanoidRootPart.CFrame = Cached + Vector3.new(0, -Offset, 0)
                            wait(Delay * 10) --10
                            HumanoidRootPart.Anchored = false
                        end
                        Resolving = false
                    end
                end
            end)
        else
            if Connection then
                Connection:Disconnect()
                Connection = nil
            end
        end
    end
})
    Misc:AddSlider('Manipulation Limit', {Text = 'Manipulation Limit', Default = 2, Min = 0,Max = 50, Rounding = 1,Compact = false, Callback = function() end});

   _G.ResolverEnabled = false
    _G.Connection = nil

    Misc:AddToggle('Peek Kill (UAC ai)', {
    Text = 'Peek Kill (Shoot to Activate)',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        _G.ResolverEnabled = state
        if _G.ResolverEnabled then
            _G.MouseInput = Enum.UserInputType.MouseButton1

            _G.Players = game:GetService("Players")
            _G.Workspace = game:GetService("Workspace")
            _G.UserInputService = game:GetService("UserInputService")
            _G.Player = _G.Players.LocalPlayer

            _G.Velocity = 1500
            _G.Delay = 0.07
            _G.Offset = 38
            _G.Resolving = false

            _G.Connection = _G.UserInputService.InputBegan:Connect(function(Input, Processed)
                if not Processed and _G.ResolverEnabled and not _G.Resolving then
                    if Input.UserInputType == _G.MouseInput then
                        _G.Resolving = true

                        local character = _G.Player.Character
                        if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Humanoid") then
                            local hrp = character.HumanoidRootPart
                            local humanoid = character.Humanoid

                            local originalCFrame = hrp.CFrame

                            local oldStates = {
                                [Enum.HumanoidStateType.Freefall] = humanoid:GetStateEnabled(Enum.HumanoidStateType.Freefall),
                                [Enum.HumanoidStateType.FallingDown] = humanoid:GetStateEnabled(Enum.HumanoidStateType.FallingDown),
                                [Enum.HumanoidStateType.Ragdoll] = humanoid:GetStateEnabled(Enum.HumanoidStateType.Ragdoll)
                            }

                            for state, enabled in pairs(oldStates) do
                                humanoid:SetStateEnabled(state, false)
                            end

                            hrp.Velocity = Vector3.new(0, _G.Velocity, 0)
                            wait(_G.Delay)

                            hrp.Anchored = true
                            hrp.CFrame = originalCFrame + Vector3.new(0, _G.Offset, 0)

                            wait(_G.Delay * 10)

                            hrp.Anchored = false

                            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)

                            for state, enabled in pairs(oldStates) do
                                humanoid:SetStateEnabled(state, enabled)
                            end
                        end

                        _G.Resolving = false
                    end
                end
            end)
        else
            if _G.Connection then
                _G.Connection:Disconnect()
                _G.Connection = nil
            end
        end
    end
})
	Misc:AddDivider()

	local Misc = Tabs.Misc:AddRightGroupbox('Spin/GangShit')
	Misc:AddDivider()
	local spinToggle = false  
	local spinSpeed = 5  

	Misc:AddToggle('SpinBot', {
    Text = 'SpinBot', 
    Default = false, 
    Tooltip = '', 
    Callback = function(state)
        spinToggle = state  
        if state then
            print("SpinBot Enabled")
        else
            print("SpinBot Disabled")
        end
    end
})

Misc:AddSlider('SpinSpeed', {
    Text = 'Spin Speed', 
    Default = 5, 
    Min = 1, 
    Max = 60, 
    Rounding = 0,
    Callback = function(value)
        spinSpeed = value
    end
})

local functions = {}

local function ToYRotation(_CFrame)
    local _, Y, _ = _CFrame:ToOrientation()
    return CFrame.new(_CFrame.Position) * CFrame.Angles(0, Y, 0)
end

local OriginalAutoRotate = localplayer.Character and localplayer.Character:FindFirstChildOfClass("Humanoid") and
	localplayer.Character:FindFirstChildOfClass("Humanoid").AutoRotate or true

local renderSteppedConnection

function functions:spin()
    camera = game:GetService("Workspace").CurrentCamera
    
    local SelfCharacter = localplayer.Character
    local SelfRootPart, SelfHumanoid = SelfCharacter and SelfCharacter:FindFirstChild("HumanoidRootPart"),
        SelfCharacter and SelfCharacter:FindFirstChildOfClass("Humanoid")
        
    if spinToggle and SelfCharacter and SelfRootPart and SelfHumanoid then
        SelfHumanoid.AutoRotate = false

        if not renderSteppedConnection then
            renderSteppedConnection = game:GetService("RunService").RenderStepped:Connect(function()
                if spinToggle and SelfRootPart then
                    local Angle = -math.atan2(camera.CFrame.LookVector.Z, camera.CFrame.LookVector.X) +
                        tick() * spinSpeed % 360
                    SelfRootPart.CFrame = ToYRotation(CFrame.new(SelfRootPart.Position) * CFrame.Angles(0, Angle, 0))
                end
            end)
        end
    else
        if SelfCharacter and SelfRootPart and SelfHumanoid then
            SelfHumanoid.AutoRotate = OriginalAutoRotate
        end
        if renderSteppedConnection then
            renderSteppedConnection:Disconnect()
            renderSteppedConnection = nil
        end
    end
end

game:GetService("RunService").RenderStepped:Connect(function()
    functions:spin()
end)
Misc:AddDivider()

local Misc = Tabs.Misc:AddRightGroupbox('Hit Sounds')
local hitsoundbool = false
local hitsoundhead = "Ding" 
local hitsoundbody = "Blackout"  

local hitsoundlib = {
["TF2"]       = "rbxassetid://8255306220",
["Gamesense"] = "rbxassetid://4817809188",
["Rust"]      = "rbxassetid://1255040462",
["Neverlose"] = "rbxassetid://8726881116",
["Bubble"]    = "rbxassetid://198598793",
["Quake"]     = "rbxassetid://1455817260",
["Among-Us"]  = "rbxassetid://7227567562",
["Ding"]      = "rbxassetid://2868331684",
["Minecraft"] = "rbxassetid://6361963422",
["Blackout"]  = "rbxassetid://3748776946",
["Osu!"]      = "rbxassetid://7151989073",
}

local hitsoundlibUI = {}
for name, _ in pairs(hitsoundlib) do
table.insert(hitsoundlibUI, name)
end

Misc:AddToggle('Hit Sounds', {
Text = 'Hit Sounds',
Default = false,
Tooltip = 'Enable or Disable Hit Sounds.',
Callback = function(v)
    hitsoundbool = v
end
})

Misc:AddDropdown('Head Sound', {
Values = hitsoundlibUI,
Default = hitsoundhead,
Tooltip = 'Choose the sound for headshots.',
Callback = function(a)
    hitsoundhead = a
    local preview = Instance.new("Sound", workspace)
    preview.SoundId = hitsoundlib[hitsoundhead]
    preview.Volume = 10 
    preview:Play()
    task.wait(1)
    preview:Destroy()
end
})

Misc:AddDropdown('Body Sound', {
Values = hitsoundlibUI,
Default = hitsoundbody,
Tooltip = 'Choose the sound for bodyshots.',
Callback = function(a)
    hitsoundbody = a
    local preview = Instance.new("Sound", workspace)
    preview.SoundId = hitsoundlib[hitsoundbody]
    preview.Volume = 3.5  
    preview:Play()
    task.wait(1)
    preview:Destroy()
end
})

localplayer.CharacterAdded:Connect(function(lchar)
local maingui = localplayer.PlayerGui:WaitForChild("MainGui")
if maingui then
    maingui.ChildAdded:Connect(function(Sound)
        if Sound:IsA("Sound") and hitsoundbool then
            if Sound.SoundId == "rbxassetid://4585351098" or Sound.SoundId == "rbxassetid://4585382589" then 
                Sound.SoundId = hitsoundlib[hitsoundhead]
                Sound.Volume = 100 
            elseif Sound.SoundId == "rbxassetid://4585382046" or Sound.SoundId == "rbxassetid://4585364605" then 
                Sound.SoundId = hitsoundlib[hitsoundbody]
                Sound.Volume = 100  
            end
        end
    end)
end
end)

localplayer.PlayerGui.MainGui.ChildAdded:Connect(function(Sound)
if Sound:IsA("Sound") and hitsoundbool then
    if Sound.SoundId == "rbxassetid://4585351098" or Sound.SoundId == "rbxassetid://4585382589" then 
        Sound.SoundId = hitsoundlib[hitsoundhead]
        Sound.Volume = 100  
    elseif Sound.SoundId == "rbxassetid://4585382046" or Sound.SoundId == "rbxassetid://4585364605" then 
        Sound.SoundId = hitsoundlib[hitsoundbody]
        Sound.Volume = 100 
    end
end
end)

	local GunMods = Tabs.GunMods:AddRightGroupbox('Other Mods')
	GunMods:AddDivider()
    local repStorage = game:GetService("ReplicatedStorage")
    local AmmoTypes = repStorage:FindFirstChild("AmmoTypes")
    local Old_Ammo = {}

if AmmoTypes then
    for _, Item in pairs(AmmoTypes:GetChildren()) do
        Old_Ammo[Item.Name] = {
            ArmorPen = Item:GetAttribute("ArmorPen") or 0,
            Damage = Item:GetAttribute("Damage") or 0
        }
    end
else
    warn("AmmoTypes not found")
end

    GunMods:AddToggle('5X Damage Bullets', {
    Text = '5X Damage Bullets',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        local AmmoTypes = repStorage:FindFirstChild("AmmoTypes")
        if not AmmoTypes then
            warn("AmmoTypes not found")
            return
        end
        
        for _, Item in pairs(AmmoTypes:GetChildren()) do
            local oldData = Old_Ammo[Item.Name]
            if oldData then
                if state then
                    Item:SetAttribute("ArmorPen", oldData.ArmorPen * 5)
                    Item:SetAttribute("Damage", oldData.Damage * 5)
                else
                    Item:SetAttribute("ArmorPen", oldData.ArmorPen)
                    Item:SetAttribute("Damage", oldData.Damage)
                end
            else
                warn("Old_Ammo missing data for", Item.Name)
            end
        end
    end
})
    
	GunMods:AddToggle('No Drag', {Text = 'No Drag', Default = false, Tooltip = '', Callback = function(state)
	if state then
	print("Enabled")

	else
	print("bye nigger")
	end
	end})
	GunMods:AddSlider('dragslider', {
		Text = 'Drag',
		Default = settings.modifiers.drag,
		Min = 0,
		Max = 200,
		Rounding = 1,
		Compact = false,
	
		Callback = function(Value)
			settings.modifiers.drag = Value
			local percentage = Value / 100 
	
			if not realAmmoTypes then
				warn("[ERROR] realAmmoTypes is nil!")
				return
			end
	
			for _, v in pairs(game.ReplicatedStorage.AmmoTypes:GetChildren()) do
				local realAmmo = realAmmoTypes:FindFirstChild(v.Name)
	
				if not realAmmo then
					warn("[WARNING] No matching ammo found for:", v.Name)
				else
					local baseDrag = realAmmo:GetAttribute("Drag")
					
					if baseDrag then
						local newDrag = baseDrag * percentage
						v:SetAttribute("Drag", newDrag)
					else
						warn("[WARNING] Drag attribute missing for:", v.Name)
					end
				end
			end
		end
	})

    GunMods:AddToggle('No Durability Loss', {Text = 'No Durability Loss', Default = false, Tooltip = '', Callback = function(state)
	if state then
	local player = game.Players.LocalPlayer
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local playersFolder = ReplicatedStorage:WaitForChild("Players")
    local playerData = playersFolder:WaitForChild(player.Name)
    local inventory = playerData:WaitForChild("Inventory")

    local protectedWeapons = {"AKMN", "SVD", "DV2", "VZ61", "PKM", "M4A1" } 

for _, itemName in ipairs(protectedWeapons) do
	local weapon = inventory:FindFirstChild(itemName)
	if weapon then
		if weapon:GetAttribute("Durability") ~= nil then
			local originalValue = weapon:GetAttribute("Durability")

			weapon:GetAttributeChangedSignal("Durability"):Connect(function()
				weapon:SetAttribute("Durability", originalValue)
			end)

			print("[NoDurabilityLoss] Protected:", weapon.Name, "at", originalValue)
		end
	end
end

	else
	print("bye nigger")
	end
	end})
    GunMods:AddToggle('Instant Mag Refill', {Text = 'Instant Mag Refill', Default = false, Tooltip = '', Callback = function(state)
	if state then
	local lplr = game:GetService("Players").LocalPlayer
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local inv = ReplicatedStorage:FindFirstChild("Players")[lplr.Name].Inventory
    local itemsList = ReplicatedStorage.ItemsList
    local remote = ReplicatedStorage.Remotes.InventoryMove

local function getType(x, y)
    if y == 'mag' then
        if itemsList:FindFirstChild(x.Name) then
            local ammoType = itemsList[x.Name].ItemProperties:GetAttribute("AmmoType")
            return ammoType
        end
    elseif y == 'ammo' then
        if itemsList:FindFirstChild(x.Name) then
            local itemType = itemsList[x.Name].ItemProperties:GetAttribute("ItemType")
            if itemType == "Ammo" then
                local slotType = itemsList[x.Name].ItemProperties:GetAttribute("SlotType")
                return slotType
            end
        end
    end
    return nil
end

local function getMaxAmmo(x)
    if itemsList:FindFirstChild(x.Name) then
        local max = itemsList[x.Name].ItemProperties:GetAttribute("MaxLoadedAmmo")
        return max
    end
    return 0
end

local function refill(bulletSlot, magSlot, bulletParent, magParent)
    remote:FireServer(bulletSlot, magSlot, bulletParent, magParent)
end

local function searchInv()
    local mags = {}
    local ammos = {}
    
    for i,v in inv:GetChildren() do
        if v:GetAttribute("Slot") then
            if v:GetAttribute("Slot"):lower():find("clothing") then
                local clothingInv = v:FindFirstChild("Inventory")
                if not clothingInv then 
                    continue 
                end
                for r,x in clothingInv:GetChildren() do
                    local loadedAmmo = x:GetAttribute("LoadedAmmo")
                    
                    if loadedAmmo ~= nil then
                        local magAmmoType = getType(x, 'mag')
                        local currentAmmo = loadedAmmo
                        local maxAmmo = getMaxAmmo(x)
                        if magAmmoType and currentAmmo < maxAmmo then
                            table.insert(mags, {item = x, ammoType = magAmmoType, slot = x:GetAttribute("Slot"), parent = clothingInv})
                        end
                    else
                        local ammoSlotType = getType(x, 'ammo')
                        if ammoSlotType then
                            table.insert(ammos, {item = x, slotType = ammoSlotType, slot = x:GetAttribute("Slot"), parent = clothingInv})
                        end
                    end
                end
            end
        end
    end

    for i, mag in mags do
        local found = false
        for i, ammo in ammos do
            if mag.ammoType == ammo.slotType then
                refill(ammo.slot, mag.slot, ammo.parent, mag.parent)
                found = true
                task.wait()
                break
            end
        end
    end
end

task.spawn(function()
    while task.wait(0.5) do
        searchInv()
    end
end)

	else
	print("bye nigger")
	end
	end})
	GunMods:AddDivider()

    local GunMods = Tabs.GunMods:AddLeftGroupbox('NoRecoil')
    GunMods:AddDivider()
    local LocalPlayer = Players.LocalPlayer
    local norecoil = false

    GunMods:AddToggle('No Recoil', {
    Text = 'No Recoil',
    Default = false,
    Callback = function(state)
        norecoil = state
    end
})

local function modify_gc_tables()
    for i, gc in ipairs(getgc(true)) do
        if type(gc) == "table" then
            if rawget(gc, "shove") and rawget(gc, "update") then
                local old_shove = gc.shove
                local old_update = gc.update

                gc.shove = function(...)
                    if norecoil then
                        return
                    end
                    return old_shove(...)
                end

                gc.update = function(...)
                    if norecoil then
                        return Vector3.zero
                    end
                    return old_update(...)
                end
            end

            if type(rawget(gc, "create")) == "function" and getinfo(gc.create).short_src == "ReplicatedStorage.Modules.SpringV2" then
                local old_create = gc.create

                gc.create = function(...)
                    local returns = old_create(...)
                    local old_shove = returns.shove
                    local old_update = returns.update

                    returns.shove = function(...)
                        if norecoil then
                            return
                        end
                        return old_shove(...)
                    end

                    returns.update = function(...)
                        if norecoil then
                            return Vector3.zero
                        end
                        return old_update(...)
                    end

                    return returns
                end
            end
        end
    end
end

    modify_gc_tables()

	GunMods:AddSlider('NoRecoil', {Text = 'Recoil Slider', Default = 100, Min = 1,Max = 100, Rounding = 1,Compact = false, Callback = function() end});
    GunMods:AddDivider()
	local nobob = false 
    local gotNoBob = false

    GunMods:AddToggle('No Weapon Bob', {
    Text = 'No Weapon Bob',
    Default = false,
    Callback = function(state)
        nobob = state
    end
})

repeat
    for i, gc in next, getgc(true) do
        if type(gc) == "table" then
            if rawget(gc, "shove") and rawget(gc, "update") then
                local originalUpdate = gc.update
                gc.update = function(...)
                    return nobob and Vector3.zero or originalUpdate(...)
                end
                gotNoBob = true
            end

            if type(rawget(gc, "create")) == "function" and getinfo(gc.create).short_src == "ReplicatedStorage.Modules.SpringV2" then
                local originalCreate = gc.create
                gc.create = function(...)
                    local spring = originalCreate(...)
                    local originalUpdate = spring.update
                    spring.update = function(...)
                        return nobob and Vector3.zero or originalUpdate(...)
                    end
                    return spring
                end
                gotNoBob = true
            end
        end
    end
    task.wait()
until gotNoBob
     
    GunMods:AddToggle('No Kick', {
    Text = 'No Kick',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        instant_hit_enabled = state
        if state then
            print("No Kick enabled")
        else
            print("No Kick disabled")
        end
    end
})

	GunMods:AddToggle('Instant Aim', {
        Text = 'Instant Aim',
        Default = false,
        Tooltip = '',
        Callback = function(state)
            if state then
                local OldSetZoomTarget
                OldSetZoomTarget = hookfunction(require(game.ReplicatedStorage.Modules.FPS).updateClient, LPH_NO_UPVALUES(function(...)
                    local args = {...}
                    
                    args[1].AimInSpeed = 0
                    args[1].AimOutSpeed = 0
    
                    return OldSetZoomTarget(unpack(args))
                end))
                
                print("Instant Aim Enabled")
            else
                print("Instant Aim Disabled")
            end
        end
    })        
	
    
    local rapidfire = false

    GunMods:AddToggle('gunmods_rapidfire', {
    Text = 'Rapid Fire',
    Default = false,
    Callback = function(state)
        rapidfire = state
    end
})

for i, gc in next, getgc(true) do
    if type(gc) == "table" and rawget(gc, "updateClient") then
        local old_update = gc.updateClient
        gc.updateClient = LPH_JIT_MAX(function(...)
            local args = {...}

            if forceauto or rapidfire then
                if rapidfire then args[1].FireRate = 0 end
                args[1].FireMode = "Auto"
            end

            return old_update(unpack(args))
        end)
    end
end

	GunMods:AddToggle('Instant Hit', {
    Text = 'Instant Hit',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        instant_hit_enabled = state
        if state then
            print("Instant hit enabled")
        else
            print("Instant hit disabled")
        end
    end
})
	GunMods:AddToggle('force full auto', {
    Text = 'Force Full Auto',
    Default = false,
    Callback = function(state)
        forceauto = first
    end
})

	local FPSModule = require(game.ReplicatedStorage.Modules.FPS)
	GunMods:AddToggle('Instant Lean', {
		Text = 'Instant Lean',
		Default = false,
		Tooltip = '',
		Callback = function(v)
			if v then 
				FPSModule.changeLean = instantleanMODfunc
			else
				FPSModule.changeLean = instantleanOGfunc
			end
		end
	})
	GunMods:AddToggle('No Bullet Drop', {
		Text = 'No Bullet Drop',
		Default = false,
		Tooltip = 'Enable',
		Callback = function(state)
			_G.InstantHitEnabled = state 
			
			if state then
				print("No Bullet Drop Enabled")	
			else
				print("No Bullet Drop Disabled")
			end
			
			for _, ammo in pairs(game.ReplicatedStorage.AmmoTypes:GetChildren()) do
				if ammo:GetAttribute("ProjectileDrop") then
					local dropAmount = state and 0 or ammo:GetAttribute("ProjectileDrop")
					ammo:SetAttribute("ProjectileDrop", dropAmount)
				end
			end
		end
	})

local instantReloadEnabled = false

local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall

setreadonly(mt, false)

mt.__namecall = newcclosure(function(obj, ...)
    local args = {...}
    local method = getnamecallmethod()

    if not checkcaller() and instantReloadEnabled then
        if method == "InvokeServer" and obj.Name == "Reload" then
            args[2] = 0
        elseif obj.ClassName == "AnimationTrack" and method == "Play" then
            if obj.Name:match("Reload") or obj.Name:match("Bolt") then
                args[1] = args[1] or 0.01 
                args[2] = 0.01           
                args[3] = 25             
            end
        end
    end

    return oldNamecall(obj, unpack(args))
end)

setreadonly(mt, true)

for _, v in pairs(getgc(true)) do
    if type(v) == "table" and rawget(v, "magazine") and rawget(v, "loadByHand") then
        local orig = v.loadByHand
        v.loadByHand = function(self, p)
            orig(self, p)

            if not instantReloadEnabled then
                return
            end

            task.wait(0.1)
            self.reloading = false
            self.cancellingReload = false

            for _, name in pairs({"Empty", "ReloadChamber", "Reload"}) do
                if self.clientAnimationTracks and self.clientAnimationTracks[name] then
                    self.clientAnimationTracks[name]:Stop()
                end
                if self.serverAnimationTracks and self.serverAnimationTracks[name] then
                    self.serverAnimationTracks[name]:Stop()
                end
            end
        end

        break
    end
end

GunMods:AddToggle('Instant Reload', {
    Text = 'Instant Reload',
    Default = false,
    Tooltip = '',
    Callback = function(v)
        instantReloadEnabled = v
    end
})

	local remove_weight_enabled = false 
    GunMods:AddToggle('Remove Weight', {
    Text = 'Remove Weight', 
    Default = false, 
    Tooltip = '', 
    Callback = function(state)
        remove_weight_enabled = state 
        if state then
            print("Remove Weight enabled")
        else
            print("Bye buddy")
        end
    end
})
	
	local instaequip = false

    GunMods:AddToggle('Instant Equip', {
    Text = 'Instant Equip',
    Default = false,
    Tooltip = 'Instantly equips your weapon without animation delay.',
    Callback = function(state)
        instaequip = state
    end
})

workspace.Camera.ChildAdded:Connect(function(ch)
    if instaequip and ch:IsA("Model") and ch:FindFirstChild("Humanoid") and ch.Humanoid:FindFirstChild("Animator") then
        task.wait(0.1)
        
        for _, v in ipairs(ch.Humanoid.Animator:GetPlayingAnimationTracks()) do
            if v.Animation and v.Animation.Name == "Equip" then
                v.TimePosition = v.Length - 0.01
                v:Stop()
            end
        end
    end
end)

local function EquipWeapon()
    if instaequip then
        local character = game.Players.LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            local humanoid = character.Humanoid
            if humanoid:FindFirstChild("Animator") then
                for _, v in ipairs(humanoid.Animator:GetPlayingAnimationTracks()) do
                    if v.Animation and v.Animation.Name == "Equip" then
                        v.TimePosition = v.Length - 0.01
                        v:Stop()
                    end
                end
            end
        end
    end
end

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton1 then
        EquipWeapon()
    end
end)

local noswaybool = false

GunMods:AddToggle('No Sway', {
    Text = 'No Sway',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        noswaybool = state
    end
})

print("Enabled") 
do
    local mod = require(game.ReplicatedStorage.Modules.FPS)
    local ogfunc = mod.updateClient

    mod.updateClient = function(a1, a2, a3)
        local arg1, arg2, arg3 = ogfunc(a1, a2, a3)
        a1table = a1

        if noswaybool then
            a1.springs.sway.Position = Vector3.new(0, 0, 0)
            a1.springs.walkCycle.Position = Vector3.new(0, 0, 0)
            a1.springs.sprintCycle.Position = Vector3.new(0, 0, 0)
            a1.springs.strafeTilt.Position = Vector3.new(0, 0, 0)
            a1.springs.jumpTilt.Position = Vector3.new(0, 0, 0)
            a1.springs.sway.Speed = 0
            a1.springs.walkCycle.Speed = 0
            a1.springs.sprintCycle.Speed = 0
            a1.springs.strafeTilt.Speed = 0
            a1.springs.jumpTilt.Speed = 0
        else
            a1.springs.sway.Speed = 4
            a1.springs.walkCycle.Speed = 4
            a1.springs.sprintCycle.Speed = 4
            a1.springs.strafeTilt.Speed = 4
            a1.springs.jumpTilt.Speed = 4
        end

        if viewmodoffset then
            a1.sprintIdleOffset = CFrame.new(Vector3.new(viewmodX, viewmodY, viewmodZ))
            a1.weaponOffset = CFrame.new(Vector3.new(viewmodX, viewmodY, viewmodZ))
        end

        return arg1, arg2, arg3
    end
end

    GunMods:AddToggle('Force Gun 4 Tap', {
    Text = "Force Gun 4 Tap",
    Default = settings.modifiers.doubletap,
    Callback = function(Value)
        settings.modifiers.doubletap = Value
    end
})

    local remove_ads_block_enabled = false 
    GunMods:AddToggle('Remove ADS Block', {
    Text = 'Remove ADS Block', 
    Default = false, 
    Tooltip = '', 
    Callback = function(state)
        remove_ads_block_enabled = state 
        if state then
            print("ADS Block Removed") 
        else
            print("ADS Block Active") 
        end
    end
}) 

    local replicatestorage = game:GetService("ReplicatedStorage")
	GunMods:AddToggle('No Spread', {
    Text = 'No Spread', 
    Default = false, 
    Tooltip = '', 
    Callback = function(value)
        local ammoFolder = replicatestorage:FindFirstChild("AmmoTypes")
        if not ammoFolder then
            warn("AmmoTypes folder not found in ReplicatedStorage")
            return
        end
        
        if value then
            for _, v in ipairs(ammoFolder:GetChildren()) do
                if v and v:GetAttribute("AccuracyDeviation") then
                    v:SetAttribute("AccuracyDeviation", 0.1)
                end
            end
        else
            for _, v in ipairs(ammoFolder:GetChildren()) do
                if v then
                    local realAmmo = realAmmoTypes and realAmmoTypes:FindFirstChild(v.Name)
                    if realAmmo and v:GetAttribute("AccuracyDeviation") then
                        v:SetAttribute("AccuracyDeviation", realAmmo:GetAttribute("AccuracyDeviation"))
                    end
                end
            end
        end
    end
})

    GunMods:AddToggle('Remove Obstructions', {
    Text = 'Remove Obstructions',
    Default = false,
    Tooltip = 'Removes gun obstructions when near walls',
    Callback = function(state)
        if state then
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local GunData = ReplicatedStorage:FindFirstChild("GunData")

            if GunData then
                for _, weapon in pairs(GunData:GetChildren()) do
                    if weapon:IsA("Folder") and weapon:FindFirstChild("Stats") then
                        local stats = weapon.Stats
                        if stats:FindFirstChild("TouchWallPosY") then stats.TouchWallPosY.Value = 0 end
                        if stats:FindFirstChild("TouchWallPosZ") then stats.TouchWallPosZ.Value = 0 end
                        if stats:FindFirstChild("TouchWallRotX") then stats.TouchWallRotX.Value = 0 end
                        if stats:FindFirstChild("TouchWallRotY") then stats.TouchWallRotY.Value = 0 end
                    end
                end
                print("No Obstructions enabled.")
            else
                warn("GunData folder not found in ReplicatedStorage!")
            end
        else
            print("No Obstructions disabled.")
        end
    end
})


    local unlockmodes = false

    GunMods:AddToggle('Unlock Fire Modes', {
    Text = 'Unlock Fire Modes',
    Default = false,
    Tooltip = 'Unlock Auto and Semi fire modes for all weapons',
    Callback = function(state)
        unlockmodes = state
    end
})

local itemslist = game.ReplicatedStorage:WaitForChild("ItemsList")
task.spawn(function()
    while task.wait(1) do
        if unlockmodes then
            local player = game.Players.LocalPlayer
            local playerData = game.ReplicatedStorage:FindFirstChild("Players")
            if not playerData then continue end

            local inv = playerData:FindFirstChild(player.Name) and playerData[player.Name]:FindFirstChild("Inventory")
            if not inv then continue end

            for _, v in ipairs(inv:GetChildren()) do
                local slot = v:GetAttribute("Slot")
                if slot and slot:lower():find("item") then
                    local itemFolder = itemslist:FindFirstChild(v.Name)
                    if itemFolder then
                        local mod = itemFolder:FindFirstChild("SettingsModule")
                        if mod then
                            local sett = require(mod)
                            if sett and typeof(sett.FireModes) == "table" then
                                sett.FireModes = {"Auto", "Semi"}
                            end
                        end
                    end
                end
            end
        end
    end
end)
    
    local repStorage = game:GetService("ReplicatedStorage") 
    GunMods:AddToggle('No Muzzle Flash', {
    Text = 'No Muzzle Flash',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        local rangedWeapons = repStorage:FindFirstChild("RangedWeapons")
        if rangedWeapons then
            if state then
                for i, v in pairs(rangedWeapons:GetChildren()) do
                    v:SetAttribute("MuzzleEffect", false)
                end
            else
                for i, v in pairs(rangedWeapons:GetChildren()) do
                    v:SetAttribute("MuzzleEffect", true)
                end
            end
        else
            warn("not working")
        end
    end
})
	GunMods:AddDivider()
   

    local WorldMods = Tabs.WorldMods:AddLeftGroupbox('World')
    WorldMods:AddDivider()
    _G.NoLeavesConnection = nil
    _G.LeafRemovalRan = false

    WorldMods:AddToggle('No Leaves', {
    Text = 'No Leaves',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        local Workspace = game:GetService("Workspace")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer

        local function removeLeaves()
            if _G.LeafRemovalRan then return end
            _G.LeafRemovalRan = true

            for _, obj in ipairs(Workspace:GetDescendants()) do
                if (obj:IsA("MeshPart") or obj:IsA("Part")) then
                    local name = obj.Name:lower()
                    if name:find("leaf") or name:find("leaves") then
                        obj.Transparency = 1
                        obj.CanCollide = false
                    end
                end
            end
        end

        if state then
            local projectDeltaPlaceId = 123456789
            if game.PlaceId == projectDeltaPlaceId then
                removeLeaves()
            end

            _G.NoLeavesConnection = LocalPlayer.CharacterAdded:Connect(function()
                task.wait(0.5)
                _G.LeafRemovalRan = false
                removeLeaves()
            end)
        else
            if _G.NoLeavesConnection then
                _G.NoLeavesConnection:Disconnect()
                _G.NoLeavesConnection = nil
            end
            _G.LeafRemovalRan = false
        end
    end
})

    WorldMods:AddToggle('No Fog', {
		Text = 'No Fog',
		Default = false,
		Tooltip = '',
		Callback = function(state)
			if state then
				local atmosphere = game:GetService("Lighting"):FindFirstChildOfClass("Atmosphere")
				if atmosphere then
					atmosphere:Destroy()
				end
			end
		end
	})
    WorldMods:AddToggle('FullBright', {Text = 'FullBright', Default = false, Tooltip = '', Callback = function(state)
	if state then
		pcall(function()
			local lighting = game:GetService("Lighting")
			local players = game:GetService("Players")
			local localPlayer = players.LocalPlayer
		
			local function applyFullbright()
				lighting.Ambient = Color3.fromRGB(255, 255, 255)
				lighting.Brightness = 2 
				lighting.FogEnd = math.huge 
				for _, effect in pairs(lighting:GetDescendants()) do
					if effect:IsA("BloomEffect") or effect:IsA("BlurEffect") or effect:IsA("ColorCorrectionEffect") or effect:IsA("SunRaysEffect") then
						effect.Enabled = false
					end
				end
			end
		
			applyFullbright()
			lighting.Changed:Connect(applyFullbright)
		
			spawn(function()
				while wait(1) do
					local character = localPlayer.Character
					if character and character:FindFirstChild("HumanoidRootPart") then
						local rootPart = character.HumanoidRootPart
						if not rootPart:FindFirstChild("Headlight") then
							local headlight = Instance.new("PointLight")
							headlight.Name = "Headlight"
							headlight.Parent = rootPart
							headlight.Brightness = 2 
							headlight.Range = 100 
							headlight.Color = Color3.fromRGB(255, 255, 255)
						end
					end
				end
			end)
		end)				

	else
	print("by nigger")
	end
	end})

    WorldMods:AddToggle('SkyBox Changer', {Text = 'Skybox Changer', Default = false, Tooltip = '', Callback = function(state)
	if state then
	print("Enabled")

	else
	print("bye nigger")
	end
	end})
	
_G.CurrentSkyboxName = "Standard"
_G.OriginalSkyboxData = nil

local Lighting = game:GetService("Lighting")
local Sky = Lighting:FindFirstChildOfClass("Sky")
if not Sky then
    Sky = Instance.new("Sky", Lighting)
end

if not _G.OriginalSkyboxData then
    _G.OriginalSkyboxData = {
        SkyboxBk = Sky.SkyboxBk,
        SkyboxDn = Sky.SkyboxDn,
        SkyboxFt = Sky.SkyboxFt,
        SkyboxLf = Sky.SkyboxLf,
        SkyboxRt = Sky.SkyboxRt,
        SkyboxUp = Sky.SkyboxUp,
    }
end

local SkyBoxes = {
    ["Standard"] = _G.OriginalSkyboxData,
    ["Among Us"] = {
        SkyboxBk = "rbxassetid://5752463190",
        SkyboxDn = "rbxassetid://5752463190",
        SkyboxFt = "rbxassetid://5752463190",
        SkyboxLf = "rbxassetid://5752463190",
        SkyboxRt = "rbxassetid://5752463190",
        SkyboxUp = "rbxassetid://5752463190"
    },
    ["Doge"] = {
        SkyboxBk = "rbxassetid://159713165",
        SkyboxDn = "rbxassetid://159713165",
        SkyboxFt = "rbxassetid://5752463190",
        SkyboxLf = "rbxassetid://5752463190",
        SkyboxRt = "rbxassetid://159713165",
        SkyboxUp = "rbxassetid://159713165"
    },
    ["Spongebob"] = {
        SkyboxBk = "rbxassetid://277099484",
        SkyboxDn = "rbxassetid://277099500",
        SkyboxFt = "rbxassetid://277099554",
        SkyboxLf = "rbxassetid://277099531",
        SkyboxRt = "rbxassetid://277099589",
        SkyboxUp = "rbxassetid://277101591"
    },
    ["Deep Space"] = {
        SkyboxBk = "rbxassetid://159248188",
        SkyboxDn = "rbxassetid://159248183",
        SkyboxFt = "rbxassetid://159248187",
        SkyboxLf = "rbxassetid://159248173",
        SkyboxRt = "rbxassetid://159248192",
        SkyboxUp = "rbxassetid://159248176"
    },
    ["Winter"] = {
        SkyboxBk = "rbxassetid://510645155",
        SkyboxDn = "rbxassetid://510645130",
        SkyboxFt = "rbxassetid://510645179",
        SkyboxLf = "rbxassetid://510645117",
        SkyboxRt = "rbxassetid://510645146",
        SkyboxUp = "rbxassetid://510645195"
    },
    ["Clouded Sky"] = {
        SkyboxBk = "rbxassetid://252760981",
        SkyboxDn = "rbxassetid://252763035",
        SkyboxFt = "rbxassetid://252761439",
        SkyboxLf = "rbxassetid://252760980",
        SkyboxRt = "rbxassetid://252760986",
        SkyboxUp = "rbxassetid://252762652"
    }
}

local function applySkybox(name)
    local data = SkyBoxes[name]
    if data then
        for face, asset in pairs(data) do
            Sky[face] = asset
        end
        _G.CurrentSkyboxName = name
    end
end

WorldMods:AddDropdown('SkyboxChange', {
    Values = { "Standard", "Among Us", "Doge", "Spongebob", "Deep Space", "Winter", "Clouded Sky" },
    Default = 3,
    Multi = false,
    Text = 'Sky',
    Callback = function(value)
        applySkybox(value)
    end
})

    WorldMods:AddToggle('No Grass', {
		Text = 'No Grass',
		Default = false,
		Tooltip = '',
		Callback = function(state)
			if state then
				sethiddenproperty(game:GetService("Workspace").Terrain, "Decoration", false)
			else
				sethiddenproperty(game:GetService("Workspace").Terrain, "Decoration", true)
			end
		end
	})
    WorldMods:AddToggle('Remove Low Health Effect', {
        Text = 'Remove Low Health Effect', 
        Default = false, 
        Tooltip = '', 
        Callback = function(state)
            task.spawn(function()
                local lighting = game:GetService("Lighting")
                local lowHealthEffect = lighting:FindFirstChild("LowHealthEffect")
            
                if lowHealthEffect then
                    lowHealthEffect:Destroy()
                    print("LowHealthEffect removed successfully.")
                else
                    print("LowHealthEffect not found.")
                end
            end)
        end
    })    
    WorldMods:AddToggle('Remove Hurt Effect', {
        Text = 'Remove Hurt Effect', 
        Default = false, 
        Tooltip = '', 
        Callback = function(state)
            task.spawn(function()
                local lighting = game:GetService("Lighting")
                local hurtEffect = lighting:FindFirstChild("HurtEffect")
            
                if hurtEffect then
                    hurtEffect:Destroy()
                    print("HurtEffect removed successfully.")
                else
                    print("HurtEffect not found.")
                end
            end)
        end
    })            
	WorldMods:AddToggle('Remove Clouds', {
        Text = 'Remove Clouds',
        Default = false,
        Tooltip = '',
        Callback = function(state)
            local clouds = game.Lighting:FindFirstChild("Clouds")
            if clouds then
                if state then
                    clouds.Density = 0
                else
                    clouds.Density = 0.5
                end
            end
        end
    })
	WorldMods:AddToggle('Remove Shadows', {
        Text = 'Remove Shadows', 
        Default = false, 
        Tooltip = 'Toggle to remove global shadows', 
        Callback = function(value)
            if value then
                game.Lighting.GlobalShadows = false  
            else
                game.Lighting.GlobalShadows = true   
            end
        end
    })      
	WorldMods:AddToggle('Remove Bloom', {
        Text = 'Remove Bloom', 
        Default = false, 
        Tooltip = 'Toggle to remove bloom effect', 
        Callback = function(state)
            local Lighting = game:GetService("Lighting")
            
            local function disableBloomEffect()
                local bloom = Lighting:FindFirstChildOfClass("BloomEffect")
                if bloom then
                    bloom.Enabled = false
                else
                    local newBloom = Instance.new("BloomEffect")
                    newBloom.Parent = Lighting
                    newBloom.Enabled = false
                end
            end
    
            local function enableBloomEffect()
                local bloom = Lighting:FindFirstChildOfClass("BloomEffect")
                if bloom then
                    bloom.Enabled = true
                else
                    local newBloom = Instance.new("BloomEffect")
                    newBloom.Parent = Lighting
                    newBloom.Enabled = true
                end
            end
    
            if state then
                disableBloomEffect()
            else
                enableBloomEffect()
            end
        end
    })    
	WorldMods:AddToggle('Remove Foliage', {
		Text = 'Remove Foliage',
		Default = false,
		Tooltip = '',
		Callback = function(state)
			if state then
				for _, v in pairs(workspace.SpawnerZones:GetDescendants()) do
					if v.ClassName == "MeshPart" and v:FindFirstChildOfClass("SurfaceAppearance") then
						v:Destroy()
					end
				end
				
				workspace.SpawnerZones.DescendantAdded:Connect(function(inst)
					wait(1)
					if inst.ClassName == "MeshPart" and inst:FindFirstChildOfClass("SurfaceAppearance") then
						inst:Destroy()
					end
				end)
			end
		end
	})
	WorldMods:AddToggle('Remove Sky', {
        Text = 'Remove Sky',
        Default = false,
        Tooltip = '',
        Callback = function(state)
            if state then
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Workspace = game:GetService("Workspace")
                
                local sky = ReplicatedStorage:FindFirstChild("Sky")
                if sky then
                    sky:Destroy()
                    print("Sky removed from ReplicatedStorage.")
                else
                    print("Sky not found in ReplicatedStorage.")
                end
                
                local clouds = Workspace.Terrain:FindFirstChild("Clouds")
                if clouds then
                    clouds:Destroy()
                    print("Clouds removed from Workspace.Terrain.")
                else
                    print("Clouds not found in Workspace.Terrain.")
                end
            end
        end
    })    
	WorldMods:AddToggle('Remove Water Blur', {
        Text = 'Remove Water Blur',
        Default = false,
        Tooltip = '',
        Callback = function(state)
            task.spawn(function()
                local lighting = game:GetService("Lighting")
                local waterBlur = lighting:FindFirstChild("WaterBlur")
                
                if waterBlur and waterBlur:IsA("BlurEffect") then
                    waterBlur.Enabled = not state  
                    if state then
                        print("WaterBlur has been successfully disabled.")
                    else
                        print("WaterBlur has been successfully enabled.")
                    end
                else
                    print("WaterBlur not found or is not a BlurEffect.")
                end
            end)
        end
    })    
    WorldMods:AddToggle('Remove SunRays', {
        Text = 'Remove SunRays',
        Default = false,
        Tooltip = '',
        Callback = function(state)
            task.spawn(function()
                local lighting = game:GetService("Lighting")
                local sunRays = lighting:FindFirstChild("SunRays")
                
                if sunRays and sunRays:IsA("SunRaysEffect") then
                    sunRays.Enabled = not state  
    
                    if state then
                        sunRays.Intensity = 0  
                        sunRays.Spread = 0   
                        print("SunRays has been successfully disabled, Intensity and Spread set to 0.")
                    else
                        print("SunRays has been successfully enabled.")
                    end
                else
                    print("SunRays not found or is not a SunRaysEffect.")
                end
            end)
        end
    })       
	WorldMods:AddToggle('Remove Rain/Sound', {
		Text = 'Remove Rain/Sound',
		Default = false,
		Tooltip = '',
		Callback = function(state)
			if state then
				local function removeWeatherEffectArea()
					local success, err = pcall(function()
						local weatherEffectArea = workspace:FindFirstChild("NoCollision") 
							and workspace.NoCollision:FindFirstChild("WeatherEffectArea")
	
						if weatherEffectArea then
							weatherEffectArea:Destroy()
							print("WeatherEffectArea has been removed.")
						else
							print("WeatherEffectArea not found.")
						end
					end)
	
					if not success then
						warn("Error removing WeatherEffectArea:", err)
					end
				end
	
				removeWeatherEffectArea()
	
				local workspaceChildren = workspace:GetChildren()
				
				if workspaceChildren[545] then
					local targetParent = workspaceChildren[545]
	
					if targetParent:FindFirstChild("LightRain") and targetParent.LightRain:FindFirstChild("LightRain") then
						targetParent.LightRain.LightRain.Playing = false
					end
	
					if targetParent:FindFirstChild("HeavyRain") and targetParent.HeavyRain:FindFirstChild("HeavyRain") then
						targetParent.HeavyRain.HeavyRain.Playing = false
					end
				end
			else
				print("Rain and sound removal is disabled.")
			end
		end
	})	
	WorldMods:AddDivider()

	local WorldMods = Tabs.WorldMods:AddRightGroupbox('Crosshair')
	WorldMods:AddDivider()
	local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

local varsglobal = {
    cursor = {
        Enabled = false,
        CustomPos = false,
        Position = Vector2.new(0, 0),
        Speed = 10,
        Radius = 25,
        Color = Color3.fromRGB(180, 50, 255),
        Thickness = 1.7,
        Outline = false,
        Resize = false,
        Dot = false,
        Gap = 10,
        TheGap = false,
        sussy = false,
        rainbow = false,
        Text = {
            Logo = false,
            LogoColor = Color3.fromRGB(255, 255, 255),
            Name = false,
            NameColor = Color3.fromRGB(255, 255, 255),
            LogoFadingOffset = 0,
        },
    }
}

local lines = {}
for i = 1, 4 do
    lines[i] = Drawing.new("Line")
    lines[i].Thickness = varsglobal.cursor.Thickness
    lines[i].Transparency = 1
    lines[i].Visible = false
end

local function updateCrosshair(delta)
    if varsglobal.cursor.Enabled then
        local mousePos = varsglobal.cursor.CustomPos and varsglobal.cursor.Position
            or Vector2.new(LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y) + Vector2.new(0, 58)

        local angle = tick() * varsglobal.cursor.Speed * math.pi / 180
        local color = varsglobal.cursor.rainbow
            and Color3.fromHSV((tick() % 5) / 5, 1, 1)
            or varsglobal.cursor.Color

        for i = 1, 4 do
            local offsetAngle = angle + (i - 1) * (math.pi / 2)
            local x1 = mousePos.X + math.cos(offsetAngle) * varsglobal.cursor.Radius
            local y1 = mousePos.Y + math.sin(offsetAngle) * varsglobal.cursor.Radius
            local x2 = mousePos.X + math.cos(offsetAngle) * (varsglobal.cursor.Radius - varsglobal.cursor.Gap)
            local y2 = mousePos.Y + math.sin(offsetAngle) * (varsglobal.cursor.Radius - varsglobal.cursor.Gap)

            lines[i].From = Vector2.new(x1, y1)
            lines[i].To = Vector2.new(x2, y2)
            lines[i].Color = color
            lines[i].Thickness = varsglobal.cursor.Thickness
            lines[i].Visible = true
        end

        if varsglobal.cursor.Dot then
            local dot = Drawing.new("Square")
            dot.Position = mousePos - Vector2.new(1, 1)
            dot.Size = Vector2.new(2, 2)
            dot.Color = varsglobal.cursor.Color
            dot.Visible = true
        end
    else
        for _, line in ipairs(lines) do
            line.Visible = false
        end
    end
end

RunService.RenderStepped:Connect(LPH_NO_VIRTUALIZE(function(delta)
    updateCrosshair(delta)
end))

WorldMods:AddToggle('crosshairenable', {
    Text = 'Enable Crosshair',
    Default = false,
    Callback = function(enabled)
        varsglobal.cursor.Enabled = enabled
    end,
}):AddColorPicker('crosshaircolor', {
    Default = varsglobal.cursor.Color,
    Title = 'Crosshair Color',
    Transparency = 0,
    Callback = function(value)
        varsglobal.cursor.Color = value
    end,
})

WorldMods:AddSlider('crosshairspeed', {
    Text = 'Speed',
    Default = 5,
    Min = 1,
    Max = 800,
    Rounding = 1,
    Compact = true,
}):OnChanged(function(value)
    varsglobal.cursor.Speed = value
end)

WorldMods:AddSlider('crosshairradius', {
    Text = 'Radius',
    Default = 25,
    Min = 5,
    Max = 100,
    Rounding = 1,
    Compact = true,
}):OnChanged(function(value)
    varsglobal.cursor.Radius = value
end)

WorldMods:AddSlider('crosshairthickness', {
    Text = 'Thickness',
    Default = 1.7,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Compact = true,
}):OnChanged(function(value)
    varsglobal.cursor.Thickness = value
end)

WorldMods:AddSlider('crosshairgapsize', {
    Text = 'Gap',
    Default = 10,
    Min = 0,
    Max = 50,
    Rounding = 1,
    Compact = true,
}):OnChanged(function(value)
    varsglobal.cursor.Gap = value
end)

WorldMods:AddToggle('crosshairenableoutline', {
    Text = 'Outline',
    Default = false,
    Callback = function(enabled)
        varsglobal.cursor.Outline = enabled
    end,
})

WorldMods:AddToggle('crosshairenableresize', {
    Text = 'Resize Animation',
    Default = false,
    Callback = function(enabled)
        varsglobal.cursor.Resize = enabled
    end,
})

WorldMods:AddToggle('crosshairenablefaggot', {
    Text = 'Rainbow',
    Default = false,
    Callback = function(enabled)
        varsglobal.cursor.rainbow = enabled
    end,
})
	WorldMods:AddDivider()

	local FovViewLeft = Tabs.FovView:AddLeftGroupbox('             Camera')
	FovViewLeft:AddDivider()
	FovViewLeft:AddToggle('Camera Fov', {Text = 'Camera Fov', Default = false, Tooltip = '', Callback = function(state)
	if state then
	print("enabled Fov")

	else
	print("bye nigger")
	end
	end})
	local GunTables = {
        AKM = true, AKMN = true, AsVal = true, IZh12 = true, IZh81 = true, M4 = true,
        MK23 = true, MP443 = true, MP5SD = true, Makarov = true, Mosin = true,
        PKM = true, PPSH41 = true, R700 = true, RPG7 = true, SKS = true, SVD = true,
        Saiga12 = true, TFZ0 = true, TFZ98S = true, TT33 = true, VZ61 = true,
    }
    
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    local currentZoomValue = 90
    
    local function applyZoomToGun(tool)
        if tool:FindFirstChild("ItemProperties") and tool.ItemProperties:FindFirstChild("Tool") and GunTables[tool.Name] then
            local zoomAmount = 120 - currentZoomValue  
            tool.ItemProperties.Tool:SetAttribute("Zoom", zoomAmount)
            tool.ItemProperties.Tool:SetAttribute("ZoomSpeed", -15)
        end
    end
    
    local function applyZoomToAllGuns()
        local playerData = ReplicatedStorage:FindFirstChild("Players"):FindFirstChild(LocalPlayer.Name)
        if not playerData then return end
    
        for _, item in pairs(playerData:GetDescendants()) do
            applyZoomToGun(item)
        end
    end
    
    local function setupGunMonitor()
        local playerData = ReplicatedStorage:FindFirstChild("Players"):FindFirstChild(LocalPlayer.Name)
        if not playerData then return end
    
        playerData.DescendantAdded:Connect(function(item)
            task.wait(0.1)
            applyZoomToGun(item)
        end)
    end
    
    FovViewLeft:AddSlider('ADS FOV', {
        Text = 'ADS FOV',
        Default = 90,
        Min = 0,
        Max = 120,
        Rounding = 1,
        Compact = false,
        Callback = function(value)
            currentZoomValue = value
            applyZoomToAllGuns()
        end
    })
    
    applyZoomToAllGuns()
    setupGunMonitor()
        
	FovViewLeft:AddSlider('Camera Fov', {
		Text = 'Fov Slider',
		Default = 90,
		Min = 0,
		Max = 120,
		Rounding = 1,
		Compact = false,
		Callback = function(state)
			updateFOV(state)
		end
	})
	
	function updateFOV(value)
		local A_1 = {
			["VisualSettings"] = {
				["ToggleDof"] = false, 
				["GlassShatter"] = true, 
				["ToggleADSDof"] = false, 
				["Sparks"] = true, 
				["Blood"] = true
			},
			["GameplaySettings"] = {
				["ToggleInteractionHighlight"] = false, 
				["ToggleCrouch"] = false, 
				["ToggleKeybindHints"] = false, 
				["ToggleSprint"] = false, 
				["FilmMakerMode"] = false, 
				["DefaultFOV"] = value 
			}
		}
	
		local Event = game:GetService("ReplicatedStorage").Remotes.UpdateSettings
		Event:FireServer(A_1)
	end
		
	FovViewLeft:AddToggle('Interactive Crosshair', {Text = 'Interactive Crosshair', Default = false, Tooltip = '', Callback = function(state)  end})
	FovViewLeft:AddToggle('Remove Inventory Blur', {
        Text = 'Remove Inventory Blur',
        Default = false,
        Tooltip = '',
        Callback = function(state)
            if state then
                task.spawn(function()
                    local lighting = game:GetService("Lighting")
                    local inventoryBlur = lighting:FindFirstChild("InventoryBlur")
                
                    if inventoryBlur and inventoryBlur:IsA("BlurEffect") then
                        inventoryBlur.Enabled = false
                        print("InventoryBlur has been disabled successfully.")
                    else
                        print("InventoryBlur not found in Lighting.")
                    end
                end)
            end
        end
    })

    FovViewLeft:AddToggle('RemoveVisor', {
    Text = 'Remove Visor',
    Default = false,
    Tooltip = 'Hides visor overlay automatically',
    Callback = function(state)
        local plr = game.Players.LocalPlayer
        local gui = plr:WaitForChild("PlayerGui")
        local visorConn
        
        local function updateVisor()
            local visor = gui:FindFirstChild("NoInsetGui", true)
                and gui.NoInsetGui:FindFirstChild("MainFrame", true)
                and gui.NoInsetGui.MainFrame:FindFirstChild("ScreenEffects", true)
                and gui.NoInsetGui.MainFrame.ScreenEffects:FindFirstChild("Visor")
            if visor then visor.Visible = not state end
        end
        
        updateVisor()
        
        if visorConn then visorConn:Disconnect() end
        if state then
            visorConn = gui.DescendantAdded:Connect(function(obj)
                if obj.Name == "Visor" then 
                    if obj:IsA("Frame") then
                        obj.Visible = false
                    end
                end
            end)
        end
    end
})

local runService = game:GetService("RunService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local players = game:GetService("Players")

while not players.LocalPlayer do task.wait() end
local localplayer = players.LocalPlayer

local settings = {
    zoom = {
        enabled = false,
        fov = 70,
        held = false
    },
    DefaultFOV = 120,
    LastFOV = nil
}

    FovViewLeft:AddToggle('Zoom', {
    Text = "Zoom",
    Default = settings.zoom.enabled,
    Callback = function(Value)
        settings.zoom.enabled = Value
    end
})

    FovViewLeft:AddLabel('Zoom Bind'):AddKeyPicker('zoombind', {
    Default = 'C',
    SyncToggleState = false,
    Mode = 'Hold',
    Text = 'Zoom',
    NoUI = false,
    Callback = function(Value) end
})

    FovViewLeft:AddSlider('zoomvalue', {
    Text = 'Zoom FOV',
    Default = settings.zoom.fov,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        settings.zoom.fov = Value
    end
})

    local playerData
    local lastCheck = 0

    local mainloop = runService.Heartbeat:Connect(function(dt)
    if not settings.zoom.enabled then return end

    if tick() - lastCheck < 0.1 then return end
    lastCheck = tick()

    local zoomBind = Options.zoombind and Options.zoombind:GetState() or false
    settings.zoom.held = zoomBind

    if not playerData then
        local found = replicatedStorage:FindFirstChild("Players")
        if found then
            local playerDataFound = found:FindFirstChild(localplayer.Name)
            if playerDataFound and playerDataFound:FindFirstChild("Settings") and playerDataFound.Settings:FindFirstChild("GameplaySettings") then
                playerData = playerDataFound.Settings.GameplaySettings
            end
        end
    end

    if playerData then
        local targetFOV = settings.zoom.held and settings.zoom.fov or settings.DefaultFOV
        if settings.LastFOV ~= targetFOV then
            playerData:SetAttribute("DefaultFOV", targetFOV)
            settings.LastFOV = targetFOV
        end
    end
end)

	FovViewLeft:AddDivider()

	local FovViewLeft = Tabs.FovView:AddRightGroupbox('         Weapon Offset')
	FovViewLeft:AddDivider()    
    
    FovViewLeft:AddLabel("Viewmodel Offset")
    FovViewLeft:AddSlider('viewmodel_x', { Text = 'X', Default = 0, Min = -5, Max = 5, Rounding = 2, Compact = true })
    FovViewLeft:AddSlider('viewmodel_y', { Text = 'Y', Default = 0, Min = -5, Max = 5, Rounding = 2, Compact = true })
    FovViewLeft:AddSlider('viewmodel_z', { Text = 'Z', Default = 0, Min = -5, Max = 5, Rounding = 2, Compact = true })

local viewmodel_x = Options.viewmodel_x
local viewmodel_y = Options.viewmodel_y
local viewmodel_z = Options.viewmodel_z

local Camera = workspace.CurrentCamera
local storedC0 = {}
local currentViewmodel = nil

local function cacheOriginalC0s(vm)
    if not vm then return end
    local hrp = vm:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    storedC0 = {}
    for _, jointName in ipairs({"LeftUpperArm", "RightUpperArm", "ItemRoot", "Motor6D"}) do
        local joint = hrp:FindFirstChild(jointName)
        if joint and joint.C0 then
            storedC0[jointName] = joint.C0
        end
    end
end

local function vmpos(vm)
    if not vm then return end
    if vm ~= currentViewmodel then
        currentViewmodel = vm
        cacheOriginalC0s(vm)
    end
    local hrp = vm:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local vec = Vector3.new(viewmodel_x.Value, viewmodel_y.Value, viewmodel_z.Value)
    for jointName, baseC0 in pairs(storedC0) do
        local joint = hrp:FindFirstChild(jointName)
        if joint and baseC0 then
            joint.C0 = baseC0 + vec
        end
    end
end

task.spawn(function()
    while task.wait(0.03) do
        local vm = Camera:FindFirstChild("ViewModel") or Camera:FindFirstChildOfClass("Model")
        if vm then
            vmpos(vm)
        else
            currentViewmodel = nil
            storedC0 = {}
        end
    end
end)

local function vmchams()
    (function()
        local vm = Camera:FindFirstChild("ViewModel") or Camera:FindFirstChildOfClass("Model")
        if not vm then return end
        vmpos(vm)
    end)()
end
	FovViewLeft:AddDivider()

	local FovView = Tabs.FovView:AddRightGroupbox('FPS Boost')
    FovView:AddSlider('FPS CAP', {
        Text = 'FPS CAP', 
        Default = 400, 
        Min = 0, 
        Max = 999, 
        Rounding = 1, 
        Compact = false, 
        Callback = function(value) 
            setfpscap(value)
        end
    });        
    
    local FovView = Tabs.FovView:AddRightGroupbox('3rd Person')

    _G.Players = game:GetService("Players")
    _G.RunService = game:GetService("RunService")
    _G.UserInputService = game:GetService("UserInputService")

    _G.localPlayer = _G.Players.LocalPlayer
    _G.Camera = workspace.CurrentCamera

    _G.thirdPersonEnabled = false
    _G.thirdPersonDistance = 5
    _G.thirdPersonHeight = 2

    --[[FovView:AddToggle('3rd Person', {
    Text = '3rd Person',
    Default = false,
    Tooltip = '',
    Callback = function(state)
        _G.thirdPersonEnabled = state
    end
})
--]]
FovView:AddLabel('3rd Person bind'):AddKeyPicker('3rd Person bind', {
    Default = 'C',
    NoUI = true,
    Text = '3rd Person bind'
})

FovView:AddSlider('Distance', {
    Text = 'Distance',
    Default = _G.thirdPersonDistance,
    Min = 0,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        _G.thirdPersonDistance = value
    end
})

FovView:AddSlider('Height', {
    Text = 'Height',
    Default = _G.thirdPersonHeight,
    Min = -5,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        _G.thirdPersonHeight = value
    end
})

_G.UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    
    if not Options or not Options['3rd Person bind'] then return end
    
    if input.KeyCode.Name == Options['3rd Person bind'].Value then
        _G.thirdPersonEnabled = not _G.thirdPersonEnabled

        if Options['3rd Person'] and Options['3rd Person'].SetValue then
            Options['3rd Person']:SetValue(_G.thirdPersonEnabled)
        end
    end
end)

_G.RunService:BindToRenderStep("ThirdPersonCamera", Enum.RenderPriority.Camera.Value + 1, function()
    if not _G.thirdPersonEnabled then return end

    local character = _G.localPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    local hrp = character.HumanoidRootPart
    local camDirection = _G.Camera.CFrame.LookVector

    local camPosition = hrp.Position
        - (camDirection * _G.thirdPersonDistance)
        + Vector3.new(0, _G.thirdPersonHeight, 0)

    _G.Camera.CFrame = CFrame.new(camPosition, hrp.Position + Vector3.new(0, _G.thirdPersonHeight, 0))
end)
    




end;


-- Functions
local Functions = { };
do

	function Functions:IsAlive(Player)
		if Player and Player.Character and Player.Character:FindFirstChild("Humanoid") and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character.Humanoid.Health > 0 then
			return true;
		end;

		return false;
	end;

	function Functions:IsVisible(Part, IgnoreList)
		local RayParams = RaycastParams.new();
		RayParams.FilterType = Enum.RaycastFilterType.Exclude;
		RayParams.FilterDescendantsInstances = (Functions:IsAlive(LocalPlayer) and {IgnoreList, LocalPlayer.Character, CurrentCamera} or {IgnoreList, CurrentCamera});
		RayParams.IgnoreWater = true;

		local Direction = (Part.Position - CurrentCamera.CFrame.Position).Unit * 5000;
		local ray = workspace:Raycast(CurrentCamera.CFrame.Position, Direction, RayParams);

		if ray and ray.Instance and ray.Instance:IsDescendantOf(Part.Parent) then
			return true;
		end;

		return false;
	end;
	
	function Functions:GetAi()
		local Ai = { };

		for _,v in pairs(AiZones:GetChildren()) do
			for _, Character in pairs(v:GetChildren()) do
				Ai[#Ai + 1] = Character;
			end;
		end;

		return Ai;
	end;
	
	function Functions:GetClosestToMouse(Fov, HitScan, WallCheck)
		local Closest, Part = Fov, nil;
		MousePos = UserInputService:GetMouseLocation();
		
		if AiZones then
			for _,Ai in pairs(Functions:GetAi()) do 
				for i2, v2 in pairs(HitScan) do
					for i3, v3 in pairs(HitBoxes[i2]) do
						local HitBoxMain = Ai:FindFirstChild(v3);
						if HitBoxMain then
							local ScreenPosition, OnScreen = CurrentCamera:WorldToScreenPoint(HitBoxMain.Position) ;
							if OnScreen and (WallCheck ~= true or Functions:IsVisible(HitBoxMain)) then
								local Distance = (Vector2.new(MousePos.X, MousePos.Y) - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude;
								if Distance < Closest then
									Closest = Distance;
									Part = HitBoxMain;
								end;
							end;
						end;
					end;
				end;
			end;
		end;

		for _, Play in pairs(game:GetService("Players"):GetPlayers()) do
			if Functions:IsAlive(Play) and Play ~= LocalPlayer then
				for i2, v2 in pairs(HitScan) do
					for i3, v3 in pairs(HitBoxes[i2]) do
						local HitBoxMain = Play.Character:FindFirstChild(v3);
						if HitBoxMain then
							local ScreenPosition, OnScreen = CurrentCamera:WorldToScreenPoint(HitBoxMain.Position) ;
							if OnScreen and (WallCheck ~= true or Functions:IsVisible(HitBoxMain)) then
								local Distance = (Vector2.new(MousePos.X, MousePos.Y) - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude;
								if Distance < Closest then
									Closest = Distance;
									Part = HitBoxMain;
								end;
							end;
						end;
					end;
				end;
			end;
		end;

		return Part;
	end;
	
	function Functions:GetAtribute(Atribute)
		local Value;
		local CurrentWeapon = game:GetService("ReplicatedStorage").Players[LocalPlayer.Name].Status.GameplayVariables.EquippedTool.Value;
		local InventoryWeapon = game:GetService("ReplicatedStorage").Players[LocalPlayer.Name].Inventory:FindFirstChild(tostring(CurrentWeapon));
		if InventoryWeapon then
			local Magazine = InventoryWeapon.Attachments:FindFirstChild("Magazine") and InventoryWeapon.Attachments:FindFirstChild("Magazine"):FindFirstChildOfClass("StringValue") and InventoryWeapon.Attachments:FindFirstChild("Magazine"):FindFirstChildOfClass("StringValue"):FindFirstChild("ItemProperties").LoadedAmmo or InventoryWeapon.ItemProperties:FindFirstChild("LoadedAmmo");
			if Magazine then
				local BulletType = Magazine:FindFirstChild("1");
				if BulletType then
					Value = game.ReplicatedStorage.AmmoTypes[BulletType:GetAttribute("AmmoType")]:GetAttribute(Atribute);
				end;
			end;
		end;
		
		return Value;
	end;
	
	function Functions:Prediction(Part, to, MuzzleVelocity, Drag)
		local Distance = (Part.Position - to).Magnitude;
		local Time = Distance / MuzzleVelocity;
		local Speed = MuzzleVelocity - Drag * MuzzleVelocity^3 * Time^3;
		Time = Time + (Distance / Speed);

		return Part.CFrame.Position + (Part.Velocity * Time);
	end;

	function Functions:BulletDrop(From, To, MuzzleVelocity, Drag, Drop)
		local Distance = (From - To).Magnitude;
		local Time = Distance / MuzzleVelocity;
		local Speed = MuzzleVelocity - Drag * MuzzleVelocity^3 * Time^3;
		Time = Time + (Distance / Speed);
		local Vertical = Drop * Time^3;

		return Vertical;
	end;
	
	function Functions:GetGun(Player)
		local CurrentWeapon = game:GetService("ReplicatedStorage").Players[Player.Name].Status.GameplayVariables.EquippedTool.Value;
		if CurrentWeapon then
			return tostring(CurrentWeapon);
		end;
		return "";
	end;

end;

-- Aimbot
local FovFill = Instance.new("Frame", FovHolder)
FovFill.BackgroundTransparency = 1
FovFill.AnchorPoint = Vector2.new(0.5, 0.5)
FovFill.Position = UDim2.fromOffset(CurrentCamera.ViewportSize.X / 2, CurrentCamera.ViewportSize.Y / 2)

local CircleCorner = Instance.new("UICorner", FovFill)
CircleCorner.CornerRadius = UDim.new(100, 100)

local FovStroke = Instance.new("UIStroke", FovFill)
FovStroke.Thickness = 1
FovStroke.LineJoinMode = Enum.LineJoinMode.Round
FovStroke.Enabled = true

local function getRainbowColor(hue)
    return Color3.fromHSV(hue % 1, 1, 1)
end

local hue = 0 

RunService.Heartbeat:Connect(function(deltaTime)
    if not Toggles.AimbotEnable.Value then
        FovFill.Visible = false
        return
    end

    FovFill.Visible = Toggles.AimbotShowFov.Value
    if FovFill.Visible then
        FovFill.Size = UDim2.fromOffset(Options.AimbotFovSize.Value, Options.AimbotFovSize.Value)
        FovFill.Position = UDim2.fromOffset(CurrentCamera.ViewportSize.X / 2, CurrentCamera.ViewportSize.Y / 2.25)

        FovStroke.Color = getRainbowColor(hue)
        hue = (hue + 0.01) % 1 
    end

    local HitBox = Functions:GetClosestToMouse(Options.AimbotFovSize.Value, Options.AimbotHitScan.Value, Toggles.AimbotWallCheck.Value)
    if not HitBox or not HitBox.Parent or not HitBox.Parent:FindFirstChild("Head") then
        return
    end

    local Head = HitBox.Parent.Head
    local ScreenPos, OnScreen = CurrentCamera:WorldToViewportPoint(Head.Position)

    local TargetVelocity = HitBox.AssemblyLinearVelocity
    local BulletVelocity = 1100 
    local Distance = (Head.Position - CurrentCamera.CFrame.Position).Magnitude

    if BulletVelocity <= 0 then
        warn("Bullet velocity must be greater than zero!")
        return
    end

    local TimeToTarget = Distance / BulletVelocity
    local PredictedPosition = Head.Position + TargetVelocity * TimeToTarget

    local Iterations = 10
    for _ = 1, Iterations do
        Distance = (PredictedPosition - CurrentCamera.CFrame.Position).Magnitude
        TimeToTarget = Distance / BulletVelocity
        PredictedPosition = Head.Position + TargetVelocity * TimeToTarget
    end

    local PredictedScreenPos, OnScreen = CurrentCamera:WorldToViewportPoint(PredictedPosition)

    local PositionX = (MousePos.X - PredictedScreenPos.X) * Options.AimbotSmoothing.Value / 3560
    local PositionY = (MousePos.Y - PredictedScreenPos.Y) * Options.AimbotSmoothing.Value / 3560

    Options.AimbotSmoothing.Value = math.max(Options.AimbotSmoothing.Value, 0.2)

    if Options.AimbotToggle:GetState() then
        mousemoverel(-PositionX, -PositionY)
    end
end)

-- Silent Aim
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

local CurrentCamera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local silent_aim = { enabled = true, target_part = nil, targetai = true, part = "Head" }
local manipulation_enabled = true
local instant_hit_enabled = true
local remove_weight_enabled = true 
--[[

Options = {
    SilentAimFovSize = {Value = 300},
    SilentAimFovOutlineColor = {Value = Color3.fromRGB(255,255,255)},
    GradientColor1 = {Value = Color3.fromRGB(255,255,255)},
    GradientColor2 = {Value = Color3.fromRGB(255,255,255)},
    SilentAimFovGradientSpeed = {Value = 50},
    FovEasingStyle = {Value = Enum.EasingStyle.Sine},
    FovEasingStyle = {Value = Enum.EasingDirection.InOut},
    SilentAimHitScan = {Value = {Arms = true, Head = true}}
}

local Toggles = {
    SilentAimShowFov = {Value = true}
}]]--


local function CreateInstance(className, properties)
    local instance = Instance.new(className)
    for prop, val in pairs(properties) do
        instance[prop] = val
    end
    return instance
end

local FovHolder = game.CoreGui:FindFirstChild("FovHolder") or Instance.new("ScreenGui")
FovHolder.Name = "FovHolder"
FovHolder.Parent = game.CoreGui

local FovOutline = CreateInstance("Frame", {
    Name = "FovOutline",
    Parent = FovHolder,
    BackgroundColor3 = Color3.fromRGB(255, 255, 255),
    BackgroundTransparency = 1,
    AnchorPoint = Vector2.new(0.5, 0.5),
    BorderSizePixel = 0,
    Position = UDim2.new(0.5, 0, 0.5, 0),
    Size = UDim2.new(0, 200, 0, 200),
})

local OutlineCorner = CreateInstance("UICorner", {
    CornerRadius = UDim.new(1, 0),
    Parent = FovOutline,
})

local OutlineStroke = CreateInstance("UIStroke", {
    Parent = FovOutline,
    Enabled = true,
    Transparency = 0,
    Color = Color3.fromRGB(0, 0, 0),
    ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
    LineJoinMode = Enum.LineJoinMode.Round,
    Thickness = 0.5,
})

local FovInline = CreateInstance("Frame", {
    Parent = FovOutline,
    BackgroundTransparency = 1,
    BorderSizePixel = 0,
    Position = UDim2.new(0, -1, 0, -1),
    Size = UDim2.new(1, 2, 1, 2),
})

local InlineCorner = CreateInstance("UICorner", {
    CornerRadius = UDim.new(1, 0),
    Parent = FovInline,
})

local InlineStroke = CreateInstance("UIStroke", {
    Parent = FovInline,
    Enabled = true,
    Transparency = 0,
    Color = Color3.fromRGB(255, 255, 255),
    ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
    LineJoinMode = Enum.LineJoinMode.Round,
    Thickness = 3,
})

local Gradient = CreateInstance("UIGradient", {
    Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 255, 255))
    },
    Rotation = 90,
    Parent = InlineStroke,
})

local CenterDot = CreateInstance("Frame", {
    Parent = FovOutline,
    BackgroundColor3 = Color3.new(1, 1, 1),
    Size = UDim2.fromOffset(4, 4),
    AnchorPoint = Vector2.new(0.5, 0.5),
    Position = UDim2.new(0.5, 0, 0.5, 0),
    Visible = false,
})

CreateInstance("UICorner", {
    CornerRadius = UDim.new(1, 0),
    Parent = CenterDot,
})

local function get_ai_targets()
    local Ai = {}
    local AiZones = Workspace:FindFirstChild("AiZones")
    if AiZones then
        for _, zone in pairs(AiZones:GetChildren()) do
            for _, character in pairs(zone:GetChildren()) do
                table.insert(Ai, character)
            end
        end
    end
    return Ai
end

local function get_hitbox_parts()
    local parts = {}
    local selected = Options.SilentAimHitScan and Options.SilentAimHitScan.Value or {Head = true}
    
    if selected.Head then
        table.insert(parts, "Head")
    end
    if selected.Torso then
        table.insert(parts, "HumanoidRootPart")
        table.insert(parts, "UpperTorso")
        table.insert(parts, "LowerTorso")
    end
    if selected.Arms then
        table.insert(parts, "RightUpperArm")
        table.insert(parts, "RightLowerArm")
        table.insert(parts, "RightHand")
        table.insert(parts, "LeftUpperArm")
        table.insert(parts, "LeftLowerArm")
        table.insert(parts, "LeftHand")
    end
    if selected.Legs then
        table.insert(parts, "RightUpperLeg")
        table.insert(parts, "RightLowerLeg")
        table.insert(parts, "RightFoot")
        table.insert(parts, "LeftUpperLeg")
        table.insert(parts, "LeftLowerLeg")
        table.insert(parts, "LeftFoot")
    end
    
    if #parts == 0 then
        table.insert(parts, "Head")
    end
    
    return parts
end

local function get_best_hitbox(character)
    local hitbox_parts = get_hitbox_parts()
    local mouse_position = Vector2.new(CurrentCamera.ViewportSize.X / 2, CurrentCamera.ViewportSize.Y / 2)
    local best_part = nil
    local min_distance = math.huge
    
    for _, part_name in ipairs(hitbox_parts) do
        local part = character:FindFirstChild(part_name)
        if part then
            local position, on_screen = CurrentCamera:WorldToViewportPoint(part.Position)
            if on_screen then
                local distance = (mouse_position - Vector2.new(position.X, position.Y)).Magnitude
                if distance < min_distance then
                    best_part = part
                    min_distance = distance
                end
            end
        end
    end
    
    return best_part, min_distance
end

local function get_target()
    local closest_target = nil
    local min_distance = math.huge
    local fov_radius = Options.SilentAimFovSize.Value / 2
    local mouse_position = Vector2.new(CurrentCamera.ViewportSize.X / 2, CurrentCamera.ViewportSize.Y / 2)

    if silent_aim.targetai then
        for _, ai in ipairs(get_ai_targets()) do
            local humanoid = ai:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local hitbox, distance = get_best_hitbox(ai)
                if hitbox and distance <= fov_radius and distance < min_distance then
                    closest_target = hitbox
                    min_distance = distance
                end
            end
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local hitbox, distance = get_best_hitbox(character)
                    if hitbox and distance <= fov_radius and distance < min_distance then
                        closest_target = hitbox
                        min_distance = distance
                    end
                end
            end
        end
    end

    return closest_target
end

local __namecall
__namecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    if checkcaller() then 
        return __namecall(self, ...) 
    end

    local method = getnamecallmethod()
    local args = { ... }

    -- manipulation
    if method == "GetAttribute" then
	    if args[1] == "MovementModifer" and remove_weight_enabled then
		    return 0
	            elseif args[1] == "ArmorPen" and wallbangEnabled then
		    return 1000
	    end
    end

    -- Instant Hit
    if instant_hit_enabled then
        if method == "FireServer" and self.Name == "ProjectileInflict" then
            if type(args[3]) == "number" and args[3] >= -20 and args[3] <= 20 then
                return coroutine.yield()
            end
            args[4] = 0 / 0
            return __namecall(self, unpack(args))
        end

        if method == "Raycast"
            and getinfo(3).short_src == "ReplicatedStorage.Modules.FPS.Bullet"
            and silent_aim.enabled and silent_aim.target_part then
            args[2] = (silent_aim.target_part.Position - args[1]).Unit * 9e16
            return __namecall(self, unpack(args))
        end
    end

    -- Force Hit
    if force_hit_enabled and method == "FireServer" and self.Name == "ProjectileInflict" then
        if silent_aim.enabled and silent_aim.target_part then
            args[2] = silent_aim.target_part
            args[3] = (silent_aim.target_part.Position - workspace.CurrentCamera.CFrame.Position).Magnitude
            args[4] = 0 / 0
            return __namecall(self, unpack(args))
        end
    end

    return __namecall(self, ...)
end))

local original_CreateBullet = require(ReplicatedStorage.Modules.FPS.Bullet).CreateBullet
local silent_aim_hook
silent_aim_hook = hookfunction(original_CreateBullet, LPH_NO_UPVALUES(function(...)
    local args = { ... }
    local target = get_target()

    -- Manipulation
    if silent_aim.enabled and manipulation_enabled and target then
        args[5] = { CFrame = CFrame.new(CurrentCamera.CFrame.Position, target.Position) }
        silent_aim.target_part = target

        -- Bullet Tracer
        if _G.BulletTracersEnabled and typeof(_G.createBeam) == "function" then
            _G.createBeam(CurrentCamera.CFrame.Position, target.Position, _G.TracerColor, _G.TracerFadeRate, _G.TracerSize)
        end

        -- Hitmarker
        if _G.HitmarkersEnabled and typeof(_G.showHitmarker) == "function" then
            _G.showHitmarker(target.Position)
        end
    else 
        silent_aim.target_part = nil
    end

     -- Force Gun 4 Tap
    if settings.modifiers and settings.modifiers.doubletap then
        if args[9] then
            args[9] = 0  
        end
        for i = 1, 2 do
            task.spawn(function()
                silent_aim_hook(table.unpack(args))  
            end)
        end
        return
    end

    return silent_aim_hook(unpack(args))
end))

RunService.Heartbeat:Connect(function()
    FovOutline.Visible = Toggles.SilentAimShowFov and Toggles.SilentAimShowFov.Value or false
    local size = Options.SilentAimFovSize and Options.SilentAimFovSize.Value or 100
    FovOutline.Size = UDim2.fromOffset(size, size)
    FovOutline.Position = UDim2.new(0.5, 0, 0.5, -25)

    if Options.SilentAimFovOutlineColor then
        OutlineStroke.Color = Options.SilentAimFovOutlineColor.Value
    end

    if Options.GradientColor1 and Options.GradientColor2 then
        Gradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, Options.GradientColor1.Value),
            ColorSequenceKeypoint.new(1, Options.GradientColor2.Value)
        }
    end

if Toggles.SilentAimFovGradientSpin and Toggles.SilentAimFovGradientSpin.Value then
    local spinSpeed = (Options.SilentAimFovGradientSpeed and Options.SilentAimFovGradientSpeed.Value) or 50
    Gradient.Rotation = (tick() * spinSpeed) % 360
end

local TweenService = game:GetService("TweenService")

if Toggles.SilentAimFovEffects and Toggles.SilentAimFovEffects.Value then
    if Toggles.SilentAimFovRainbow and Toggles.SilentAimFovRainbow.Value then
        local spinSpeed = (Options.SilentAimFovGradientSpeed and Options.SilentAimFovGradientSpeed.Value) or 50
        local targetRotation = (tick() * spinSpeed) % 360
        local easingStyle = (Options.FovEasingStyle and Options.FovEasingStyle.Value) or Enum.EasingStyle.Sine
        local easingDirection = (Options.FovEasingDirection and Options.FovEasingDirection.Value) or Enum.EasingDirection.InOut
        TweenService:Create(
            Gradient,
            TweenInfo.new(0.25, easingStyle, easingDirection, 0, false, 0),
            {Rotation = targetRotation}
        ):Play()
        Gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 110, 110)),  -- soft red
            ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 255, 150)),  -- bright yellow
            ColorSequenceKeypoint.new(0.34, Color3.fromRGB(160, 255, 170)),  -- light green
            ColorSequenceKeypoint.new(0.51, Color3.fromRGB(150, 230, 255)),  -- sky blue
            ColorSequenceKeypoint.new(0.68, Color3.fromRGB(210, 160, 255)),  -- light violet
            ColorSequenceKeypoint.new(0.85, Color3.fromRGB(255, 160, 220)),  -- soft pink
            ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 110, 110)),  -- loop red
        })
    end
else
    local outlineColor = (Options.SilentAimFovOutlineColor and Options.SilentAimFovOutlineColor.Value) or Color3.fromRGB(255, 255, 255)
    Gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, outlineColor),
        ColorSequenceKeypoint.new(1, outlineColor)
    })
end

    CenterDot.Visible = Toggles.SilentAimShowCenterDot and Toggles.SilentAimShowCenterDot.Value or false

    local target = get_target()
    if aimtrigger and target and not UserInputService.MouseIconEnabled then
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
            task.spawn(function()
                mouse1press()
                wait()
                mouse1release()
            end)
        end
    end
end)

-- ESP 
do

    local ESPHolder = Instance.new("ScreenGui", game.CoreGui)
    ESPHolder.Name = "CornerBoxESP"

    local function AddESP(Player)
	local function OnCharacterAdded(Character)
		local existing = ESPHolder:FindFirstChild(Player.Name)
		if existing then existing:Destroy() end

		local BoxFill = Instance.new("Frame", ESPHolder)
		BoxFill.BorderSizePixel = 1                    
		BoxFill.BorderColor3 = Color3.fromRGB(0, 0, 0)  
		BoxFill.ZIndex = 5

		local FillGradient = Instance.new("UIGradient", BoxFill)

		local CornerHolder = Instance.new("Folder", ESPHolder)
		CornerHolder.Name = Player.Name

		local Lines = {}
		local lineThickness = 2.8
		for i = 1, 8 do
			local line = Instance.new("Frame", CornerHolder)
			line.BorderSizePixel = 0
			line.Visible = false
			line.ZIndex = 6
			line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Lines[i] = line
		end

		local Name = Instance.new("TextBox", ESPHolder)
		local Gun = Instance.new("TextBox", ESPHolder)
		local Connection

		Gun.TextColor3 = Color3.fromRGB(255, 255, 255)
		Gun.BackgroundTransparency = 1
		Gun.TextSize = 12.5
		Gun.Text = ""
		Gun.RichText = true
		Gun.Font = Enum.Font.Code

		Name.TextColor3 = Color3.fromRGB(255, 255, 255)
		Name.BackgroundTransparency = 1
		Name.TextSize = 12.5
		Name.Text = Player.Name
		Name.RichText = true
		Name.Font = Enum.Font.Code

		local function DestroyESP()
			if Connection then Connection:Disconnect() end
			BoxFill:Destroy()
			FillGradient:Destroy()
			CornerHolder:Destroy()
			Name:Destroy()
			Gun:Destroy()
		end

		local function HideESP()
			BoxFill.Visible = false
			for _, l in ipairs(Lines) do l.Visible = false end
			Gun.Visible = false
			Name.Visible = false
		end

		local function UpdateCornerBox(position, size, color)
			local x, y = position.X, position.Y
			local w, h = size.X, size.Y
			local lw, lh = w * 0.25, h * 0.25

			local points = {
				{x, y, lw, lineThickness},
				{x, y, lineThickness, lh},
				{x + w - lw, y, lw, lineThickness},
				{x + w - lineThickness, y, lineThickness, lh},
				{x, y + h - lineThickness, lw, lineThickness},
				{x, y + h - lh, lineThickness, lh},
				{x + w - lw, y + h - lineThickness, lw, lineThickness},
				{x + w - lineThickness, y + h - lh, lineThickness, lh},
			}

			for i, l in ipairs(Lines) do
				local px, py, pw, ph = unpack(points[i])
				l.Position = UDim2.fromOffset(px, py)
				l.Size = UDim2.fromOffset(pw, ph)
				l.BackgroundColor3 = color
				l.Visible = true
			end
		end

		Connection = RunService.Heartbeat:Connect(function()
			if not Toggles.DrawESP.Value then return HideESP() end
			if not Player or not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then return HideESP() end
			if not Functions:IsAlive(Player) then return HideESP() end

			local HumanoidRoot = Player.Character.HumanoidRootPart
			local ScreenPos, OnScreen = CurrentCamera:WorldToScreenPoint(HumanoidRoot.Position)
			if not OnScreen then return HideESP() end

			local frustumHeight = math.tan(math.rad(CurrentCamera.FieldOfView * 0.5)) * 2 * ScreenPos.Z

			local size = CurrentCamera.ViewportSize.Y / frustumHeight * Vector2.new(3.3, 6.3)
            local topOffset = 4 
            local position = Vector2.new(ScreenPos.X, ScreenPos.Y) - (size / 2) + Vector2.new(0, topOffset)

			local TopTextY = (ScreenPos.Y - (size.Y + Name.TextBounds.Y + 19) / 2)
			local BottomTextY = (ScreenPos.Y + (size.Y + Gun.TextBounds.Y + 19) / 2)
			local GradientRotation = -90
			local DistanceInMeters = math.floor((CurrentCamera.CFrame.Position - HumanoidRoot.Position).Magnitude / 3.571)

			BoxFill.Position = UDim2.fromOffset(position.X, position.Y)
			BoxFill.Size = UDim2.fromOffset(size.X, size.Y)
			if Toggles.DrawFill.Value then
				BoxFill.Visible = true
				BoxFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				BoxFill.BackgroundTransparency = Options.DrawFillTransparency.Value / 100

				if Toggles.DrawGradients.Value then
					FillGradient.Enabled = true
					FillGradient.Color = ColorSequence.new{
						ColorSequenceKeypoint.new(0, Options.Fill1.Value),
						ColorSequenceKeypoint.new(1, Options.Fill2.Value)
					}
					if Toggles.ESPAnimation.Value then
						FillGradient.Rotation += 1
					else
						FillGradient.Rotation = GradientRotation
					end
				else
					FillGradient.Enabled = false
					BoxFill.BackgroundColor3 = Options.Fill1.Value
				end
			else
				BoxFill.Visible = false
			end

			if Toggles.DrawBoxes.Value then
				UpdateCornerBox(position, size, Options.Boxes1.Value)
			else
				for _, l in ipairs(Lines) do l.Visible = false end
			end

			if Toggles.DrawName.Value or Toggles.DrawDstance.Value then
				Name.Visible = true
				Name.Text = (
					Toggles.DrawName.Value and Toggles.DrawDstance.Value and
					string.format('<font color="rgb(%d,%d,%d)">%s</font> [<font color="rgb(%d,%d,%d)">%dm</font>]',
						Options.Name1.Value.R*255, Options.Name1.Value.G*255, Options.Name1.Value.B*255,
						Player.Name,
						Options.Distance1.Value.R*255, Options.Distance1.Value.G*255, Options.Distance1.Value.B*255,
						DistanceInMeters)
					or (Toggles.DrawName.Value and
					string.format('<font color="rgb(%d,%d,%d)">%s</font>', Options.Name1.Value.R*255, Options.Name1.Value.G*255, Options.Name1.Value.B*255, Player.Name))
					or (Toggles.DrawDstance.Value and
					string.format('[<font color="rgb(%d,%d,%d)">%dm</font>]', Options.Distance1.Value.R*255, Options.Distance1.Value.G*255, Options.Distance1.Value.B*255, DistanceInMeters))
				)
				Name.Position = UDim2.fromOffset(ScreenPos.X, TopTextY)
			else
				Name.Visible = false
			end

			if Toggles.DrawGun.Value then
				Gun.TextColor3 = Options.Gun1.Value
				Gun.Visible = true
				Gun.Position = UDim2.fromOffset(ScreenPos.X, BottomTextY)
				Gun.Text = Functions:GetGun(Player)
			else
				Gun.Visible = false
			end
		end)

		Character.AncestryChanged:Connect(function(_, parent)
			if not parent then
				DestroyESP()
			end
		end)
	end

	if Player.Character then
		OnCharacterAdded(Player.Character)
	end
	Player.CharacterAdded:Connect(OnCharacterAdded)
end

for _, v in pairs(Players:GetPlayers()) do
	if v ~= LocalPlayer then
		AddESP(v)
	end
end

Players.PlayerAdded:Connect(function(v)
	if v ~= LocalPlayer then
		AddESP(v)
	end
end)
	
	-- NPC ESP
	local function AddNPCESP(Character)
		local BoxFill = Instance.new("Frame", ESPHolder);
		local Box = Instance.new("UIStroke", BoxFill);
		local FillGradient = Instance.new("UIGradient", BoxFill);
		local BoxGradient = Instance.new("UIGradient", Box);
		local Name = Instance.new("TextBox", ESPHolder);
		local Connection;

		Name.TextColor3 = Color3.fromRGB(255, 255, 255);
		Name.BackgroundTransparency = 1;
		Name.TextSize = 11;
		Name.Text = Character.Name;
		Name.RichText = true;
		Name.Font = Enum.Font.Code;

		local function DestroyESP()
			BoxFill:Destroy();
			Box:Destroy();
			FillGradient:Destroy();
			BoxGradient:Destroy();
			Name:Destroy();
			Connection:Disconnect();
		end;

		local function HideESP()
			BoxFill.Visible = false;
			Box.Enabled = false;
			FillGradient.Enabled = false;
			BoxGradient.Enabled = false;
			Name.Visible = false;
		end;


		Connection = RunService.Heartbeat:Connect(function()

			if not Toggles.DrawESP.Value then
				return HideESP();
			end;
			
			if not Character then
				return DestroyESP();
			end;

			local HumanoidRoot = Character:FindFirstChild("HumanoidRootPart");
			if not HumanoidRoot then
				return HideESP(); 
			end;

			local ScreenPosition, OnScreen = CurrentCamera:WorldToScreenPoint(HumanoidRoot.Position);
			if not OnScreen then
				return HideESP();
			end;

			local frustumHeight = math.tan(math.rad(CurrentCamera.FieldOfView * 0.5)) * 2 * ScreenPosition.Z;
			local size = CurrentCamera.ViewportSize.Y / frustumHeight * Vector2.new(5,6);
			local position = Vector2.new(ScreenPosition.X, ScreenPosition.Y) - size / 2;
			local TopTextY = (ScreenPosition.Y - (size.Y + Name.TextBounds.Y + 19) / 2);
			--local bottomTextY = (ScreenPosition.Y + (size.Y + Weapons.TextBounds.Y + 19) / 2);
			local GradientRotation = -90;
			local Distance = (CurrentCamera.CFrame.Position - Character.Head.Position).Magnitude;

			BoxFill.Position = UDim2.fromOffset(position.X, position.Y);
			BoxFill.Size = UDim2.fromOffset(size.X, size.Y);

			if Toggles.DrawBoxes.Value then
				BoxFill.Visible = true;
				Box.Enabled = true;

				if Toggles.DrawGradients.Value then
					BoxGradient.Enabled = true;
					Box.Color = Color3.fromRGB(255, 255, 255);
					BoxGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Options.Boxes1.Value), ColorSequenceKeypoint.new(1, Options.Boxes2.Value)};
					if Toggles.ESPAnimation.Value then
						BoxGradient.Rotation += 1;
					else
						BoxGradient.Rotation = GradientRotation;
					end;
				else
					BoxGradient.Enabled = false;
					Box.Color = Options.Boxes1.Value;
				end;

			else
				Box.Enabled = false;
			end;

			if Toggles.DrawFill.Value then
				BoxFill.Transparency = Options.DrawFillTransparency.Value / 100;

				if Toggles.DrawGradients.Value then
					FillGradient.Enabled = true;
					BoxFill.BackgroundColor3 = Color3.fromRGB(255 ,255 ,255);
					FillGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Options.Fill1.Value), ColorSequenceKeypoint.new(1, Options.Fill2.Value)};
					if Toggles.ESPAnimation.Value then
						FillGradient.Rotation += 1;
					else
						FillGradient.Rotation = GradientRotation;
					end;
				else
					FillGradient.Enabled = false;
					BoxFill.BackgroundColor3 = Options.Fill1.Value;
				end;

			else
				BoxFill.Transparency = 1;
			end;

			if Toggles.DrawName.Value or Toggles.DrawDstance.Value then
				Name.Position = UDim2.fromOffset(position.X, TopTextY);
				Name.Visible = true;
				Name.Text = (Toggles.DrawName.Value and Toggles.DrawDstance.Value and string.format('<font color="rgb(%d, %d, %d)">'.. Character.Name ..'</font>', Options.Name1.Value.R * 255, Options.Name1.Value.G * 255, Options.Name1.Value.B * 255) .. " " .. string.format('[<font color="rgb(%d, %d, %d)">'.. math.floor(Distance) ..'</font>]', Options.Distance1.Value.R * 255, Options.Distance1.Value.G * 255, Options.Distance1.Value.B * 255) or Toggles.DrawName.Value and string.format('<font color="rgb(%d, %d, %d)">'.. Character.Name ..'</font>', Options.Name1.Value.R * 255, Options.Name1.Value.G * 255, Options.Name1.Value.B * 255) or Toggles.DrawDstance.Value and string.format('[<font color="rgb(%d, %d, %d)">'.. math.floor(Distance) ..'</font>]', Options.Distance1.Value.R * 255, Options.Distance1.Value.G * 255, Options.Distance1.Value.B * 255));
				Name.Position = UDim2.fromOffset(ScreenPosition.X, TopTextY);	
			else
				Name.Visible = false;
			end;

		end);
	end;

	for i,v in pairs(Functions:GetAi()) do
		AddNPCESP(v);
	end;
	
	for _,v in pairs(AiZones:GetChildren()) do
		v.ChildAdded:Connect(function(v)
			if v:IsA("Model") then
				AddNPCESP(v);
			end;
		end);
	end;
end;

print("instant lean Enabled")
instantleanMODfunc = function(a1,a2,a3)
    if a2 == 0 then 
        if a1.lean == 0 then return end
    end
    local carv = a1.rs_Vehicle.CurrentSeat.Value
    if carv then 
        if a1.lean == 0 then return end
    end
    if a1.humanoid:GetState() == Enum.HumanoidStateType.Swimming then 
        if a1.lean == 0 then return end
    end
    if a1.sprinting == true then 
        if a1.lean == 0 then return end
    end
    
    if a2 == a1.lean then 
        a1.lean = 0
    else 
        a1.lean = a2
    end
    
    local springs = a1.springs
    local lalpha = springs.leanAlpha
    springs.leanAlpha.Speed = 15
    local currentlean = a1.lean
    local vectorposidk = Vector3.new(-currentlean, 0,0)
    lalpha.Target = vectorposidk
    local valuetoserver = nil
    
    if lalpha.Target.X == 1 then 
        valuetoserver = true
    elseif lalpha.Target.X == -1 then
        valuetoserver = false
    end

    game.ReplicatedStorage.Remotes.UpdateLeaning:FireServer(valuetoserver)
end
instantleanOGfunc = function(a1,a2,a3)
    if a2 == 0 then 
        if a1.lean == 0 then return end
    end
    local carv = a1.rs_Vehicle.CurrentSeat.Value
    if carv then 
        if a1.lean == 0 then return end
    end
    if a1.humanoid:GetState() == Enum.HumanoidStateType.Swimming then 
        if a1.lean == 0 then return end
    end
    if a1.sprinting == true then 
        if a1.lean == 0 then return end
    end
    
    if a2 == a1.lean then 
        a1.lean = 0
    else 
        a1.lean = a2
    end
    
    local springs = a1.springs
    local lalpha = springs.leanAlpha
    springs.leanAlpha.Speed = 5
    local currentlean = a1.lean
    local vectorposidk = Vector3.new(-currentlean, 0,0)
    lalpha.Target = vectorposidk
    local valuetoserver = nil
    
    if lalpha.Target.X == 1 then 
        valuetoserver = true
    elseif lalpha.Target.X == -1 then
        valuetoserver = false
    end

    game.ReplicatedStorage.Remotes.UpdateLeaning:FireServer(valuetoserver)
end

--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
--END
